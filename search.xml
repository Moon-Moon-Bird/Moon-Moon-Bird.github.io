<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅析JVM虚拟机</title>
    <url>/2019/10/21/%E6%B5%85%E6%9E%90JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="JVM体系结构概览"><a href="#JVM体系结构概览" class="headerlink" title="JVM体系结构概览:"></a>JVM体系结构概览:</h1><p><img src="https://i.loli.net/2019/10/21/LX7vHKuqbhcERGT.png" alt="jvm架构图.png"></p><h2 id="1-类加载器ClassLoader"><a href="#1-类加载器ClassLoader" class="headerlink" title="1.类加载器ClassLoader"></a>1.类加载器ClassLoader</h2><p>​    赋值加载class文件,class文件在<strong>文件开头有特定的文件标示</strong>,将class文件字节码内容加载到内存中,并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载,只与它是否可以运行,由Execution Engine决定</p><a id="more"></a>

<p><img src="https://i.loli.net/2019/10/21/2nmYXqw1OPDWTkM.png" alt="类加载过程.png"></p>
<h3 id="class和Class的区别"><a href="#class和Class的区别" class="headerlink" title="class和Class的区别:"></a>class和Class的区别:</h3><ol>
<li><p>class只用于类声明;(关键字)</p>
</li>
<li><p>Class( java.lang.Class )则用于抽象类的相关信息. java是<a href="https://www.baidu.com/s?wd=面向对象&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">面向对象</a>的, 一般是把一些事物抽象成一个类,比如将学生信息抽象成Student这个类;Student类会抽象学生的姓名/性别/生日等信息; </p>
<p>Class相当于类的模板,装在JVM的方法区</p>
</li>
</ol>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器:"></a>虚拟机自带的加载器:</h3><ul>
<li>启动类加载器(Bootstrap) C++  <strong>在程序中打印出来是null</strong>(Object.getclass())</li>
<li>扩展类加载器(Extension) Java</li>
<li>应用程序类加载器(AppClassLoader) Java , 页脚系统类加载器,加载当前应用的classpath的所有类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyObject是自定义类</span></span><br><span class="line">MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="comment">//null  Bootstrap</span></span><br><span class="line">System.out.println(myObject.getClass().getClassLoader().getParent().getParent());</span><br><span class="line"><span class="comment">//extClassLoader</span></span><br><span class="line">System.out.println(myObject.getClass().getClassLoader().getParent());</span><br><span class="line"><span class="comment">//AppClassLoader</span></span><br><span class="line">System.out.println(myObject.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1540e19</span>d</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure>

<p><strong>用户自定义加载器:</strong></p>
<p>Java.lang.ClassLoader的子类,用户可以定制类的加载方式</p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派:"></a>双亲委派:</h3><p><img src="https://i.loli.net/2019/10/21/2xXG4pmNqr6vMuI.png" alt="双亲委派.png"></p>
<p><strong>加载流程：</strong></p>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<p>​    采用双亲委派的一个好处就是比如加载位于rt.jar包中的类java.lang.Object,不管是哪个加载器加载这个类,最终都是委托给顶层的启动类加载器进行加载,这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象</p>
<h3 id="沙箱安全"><a href="#沙箱安全" class="headerlink" title="沙箱安全"></a>沙箱安全</h3><p>​    沙箱安全机制是由基于双亲委派机制上 采取的一种JVM的自我保护机制,假设你要写一个java.lang.String 的类,由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类,因此就保证了java的运行机制不会被破坏.</p>
<h2 id="2-Native-Interface本地接口"><a href="#2-Native-Interface本地接口" class="headerlink" title="2.Native Interface本地接口"></a>2.Native Interface本地接口</h2><p>​    本地接口的作用是融合不同的编程语言为Java所有</p>
<p><strong>Native Method Stack</strong>    </p>
<p>​    它的具体做法是Native Method Stack中等级native方法,在Execution Engine执行时加载本地方法库</p>
<h2 id="3-PC寄存器"><a href="#3-PC寄存器" class="headerlink" title="3.PC寄存器"></a>3.PC寄存器</h2><p>​    每个线程都有一个程序计数器,是线程私有的,就是一个指针,指向方向区中的方法字节码<strong>(用来存储指向下一条指令的地址,也即将要执行的指令代码)</strong>,由执行引擎读取下一条指令,是一个非常小的内存空间,几乎可以忽略不计.</p>
<p>​    这款内存区域很小,<strong>它是当前线程所执行的字节码的行号指示器</strong>,字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令.</p>
<p>​    如果执行的是一个Native方法,那这个计数器是空的.</p>
<p>​    用以完成分支,循环,跳转,异常处理,线程恢复等基础功能.不会发生内存溢出<strong>(OutOfMemory=OOM)</strong>错误</p>
<h2 id="4-方法区-Method-Area"><a href="#4-方法区-Method-Area" class="headerlink" title="4.方法区 Method Area"></a>4.方法区 Method Area</h2><p>​    供各线程共享的运行时内存区域.<strong>它存储了每一个类的结构信息</strong>,例如运行时常量池(Runtime Constant Pool),字段和方法数据,构造函数和普通方法的字节码内容.</p>
<p>​    上面讲的是规范,在不同虚拟机里头实现是不一样的,最典型的就是永久代(PermGen space)和元空间(Metaspace)</p>
<p><strong>BUT</strong></p>
<p><strong>实例变量存在堆内存中,和方法区无关</strong></p>
<h2 id="5-栈"><a href="#5-栈" class="headerlink" title="5.栈"></a>5.栈</h2><h3 id="栈管运行-堆管存储"><a href="#栈管运行-堆管存储" class="headerlink" title="栈管运行,堆管存储"></a>栈管运行,堆管存储</h3><p>(队列:先进先出   栈:先进后出)</p>
<p>​    栈也叫栈内存,主管Java程序的运行,是在线程创建时创建,它的生命期是跟随线程的生命期,线程结束栈内存也就释放,<strong>对于栈来说不存在垃圾回收问题</strong>,只要线程一结束栈就over,<strong>生命周期和线程一致,是线程私有的</strong>.<strong>8种基本类型的变量+对象的引用变量+实例方法</strong>都是函数的栈内存中分配.</p>
<h3 id="栈存储什么"><a href="#栈存储什么" class="headerlink" title="栈存储什么?"></a>栈存储什么?</h3><p>java的方法进栈后,变<strong>栈帧</strong></p>
<p>栈帧中主要保存3类数据:</p>
<ol>
<li>本地变量:输入参数和输出参数以及方法内的变量</li>
<li>栈操作:记录出栈,入栈的操作</li>
<li>栈帧数据:包括类文件,方法等等.</li>
</ol>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理:"></a>栈运行原理:</h3><p>​    栈中的数据都是以栈帧的格式存在,栈帧是一个内存区块,是一个数据集,是一个有关方法和运行期数据的数据集,遵循先进后出,后进先出的原则</p>
<p>​    <strong>每个方法执行的同时都会创建一个栈帧,用于存储局部变量表,操作数栈,动态链接,方法出口等信息</strong>,每一个方法从调用直至执行完毕的过程,就对应者一个栈帧在虚拟机中入栈到出栈的过程.栈的大小和具体JVM的实现有关,通常在256k~756k之间,或者1Mb左右</p>
<p><img src="https://i.loli.net/2019/10/21/YCuEe3WXwPVJTfZ.png" alt="栈帧.png"></p>
<p><img src="https://i.loli.net/2019/10/21/TFvIfOP4oLwjyWG.png" alt="栈帧2.png"></p>
<p>每执行一个方法都会产生一个栈帧,保存到栈的顶部(后进先出),<strong>顶部栈就是当前的方法,该方法执行完毕后会自动将此栈帧出栈</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1111111111"</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">"2222222222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序运行后:出现<strong>java.lang.StackOverflowError</strong>(栈溢出)</p>
<h2 id="6-栈-堆-方法区的相互关系"><a href="#6-栈-堆-方法区的相互关系" class="headerlink" title="6.栈+堆+方法区的相互关系"></a>6.栈+堆+方法区的相互关系</h2><p><img src="https://i.loli.net/2019/10/21/qu2oV9KskyjWTAX.png" alt="栈堆方法区相互关系.png"></p>
<h2 id="7-堆heap"><a href="#7-堆heap" class="headerlink" title="7.堆heap"></a>7.堆heap</h2><h3 id="堆体系结构概述"><a href="#堆体系结构概述" class="headerlink" title="堆体系结构概述:"></a>堆体系结构概述:</h3><p>​    一个JVM实例只存在一个堆内存,堆内存大小可调节,类加载器读取了类文件后,需要把类,方法,常变量放到堆内存中,保存所有引用类型的真实信息,以方便执行器执行,堆内存分为以下三部分:</p>
<ul>
<li><strong>Young Generation Space 新生区    Young/New</strong></li>
<li><strong>Tenure Generation Space 养老区   Old/Tenure</strong></li>
<li><strong>Permanent Space   永久区               Perm</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/10/21/i4RQhyVY1HwBnfm.png" alt="新生区.png"></p>
<p>幸存0区=from</p>
<p>幸存1区=to</p>
<p>from区和to区,他们的位置和名分,不是固定的,每次GC后会交换</p>
<p>GC之后有交换,谁空谁是to</p>
<p><img src="https://i.loli.net/2019/10/21/Wpmcot8T9MJuXK2.png" alt="堆结构.png"></p>
<p><strong>MinorGC的过程(复制-&gt;清空-&gt;互换</strong>)</p>
<ol>
<li><p><strong>eden,From复制到To,年龄+1</strong></p>
<p>首先,eden满的时候触发第一次GC,把还活着的对象拷贝到From区,当eden区再次触发GC的时候会扫描eden区和from区,对这两个区域进行垃圾回收,经过这次回收后还存活的对象,复制到To区(如果有对象的年龄达到了老年标准,则赋值到老年区),同时把这些对象的年龄+1</p>
</li>
<li><p><strong>清空eden,From</strong></p>
<p>然后,清空eden和from中的对象,复制之后有交换,<strong>谁空谁是to区</strong></p>
</li>
<li><p><strong>To和From互换</strong></p>
<p>最后,To和From互换,原To去成为下一次GC时的From区,部分对象会在From和To区域中复制来复制去,交换15次(由JVM参数MaxTenuringThreshold决定),最终还是存活就进入老年区</p>
</li>
</ol>
<h3 id="永久区-java7之前有"><a href="#永久区-java7之前有" class="headerlink" title="永久区(java7之前有)"></a>永久区(java7之前有)</h3><p>​    永久存储区是一个常驻内存区域,用于存放JDK自身所携带的Class,Interface的元数据,也就是说它存储的是运行环境必须的类信息,被装载进此区域的数据是不会被垃圾回收器回收掉的,关闭JVM才会释放此区域所占用的内存</p>
<p>​    在java8中,永久代已经被移除,被一个成为元空间的区域所取代.元空间的本质和永久代类似.</p>
<p>元空间与永久代之间最大的<strong>区别在于</strong>:</p>
<p>​    永久代使用的是JVM的堆内存,<strong>元空间并不在虚拟机中,而是使用本机物理内存</strong></p>
<p>​    因此,默认情况下,元空间的大小仅受本地内存限制.类的元数据放入native memory.字符串池和类的静态变量放入java堆中,这样加载多少类的元数据就不再由MaxPermSize控制,而由系统的实际可用空间来控制.</p>
<h2 id="8-堆内存调优"><a href="#8-堆内存调优" class="headerlink" title="8.堆内存调优"></a>8.堆内存调优</h2><table>
<thead>
<tr>
<th align="center">-Xms</th>
<th>设置初始分配大小,默认为物理内存的1/64</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xmx</td>
<td>最大分配内存,默认为物理内存的1/4</td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td>输出详细的GC处理日志</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回java虚拟机试图使用的最大内存量</span></span><br><span class="line"><span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="comment">//返回java虚拟机中的内存总量</span></span><br><span class="line"><span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">System.out.println(<span class="string">"-Xmx:maxMemory = "</span> + (maxMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">System.out.println(<span class="string">"-Xms:totalMemory = "</span> + (totalMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">-Xmx:maxMemory = <span class="number">1787.0</span>MB</span><br><span class="line">-Xms:totalMemory = <span class="number">121.0</span>MB</span><br></pre></td></tr></table></figure>

<p><strong>java.lang.OutOfMemoryError:java heap space</strong></p>
<p>若老年区执行了Full GC之后发现依然无法进行对象的保存,就会产生OOM异常<strong>OutOfMemoryError</strong></p>
<p>出现这个异常原因有二:</p>
<ol>
<li>java虚拟机的堆内存设置不够,可以通过参数-Xms,-Xmx来调整</li>
<li>代码中创建了大量大对象,并且长时间不能被垃圾收集器手机(存在被引用)</li>
</ol>
<p>idea修改这两个参数:</p>
<p><img src="https://i.loli.net/2019/10/21/27XMOkuvHU1laZs.png" alt="idea堆内存参数设置.png"></p>
<h3 id="GC收集日志信息"><a href="#GC收集日志信息" class="headerlink" title="GC收集日志信息:"></a>GC收集日志信息:</h3><p><img src="https://i.loli.net/2019/10/21/zyN7fSXG3rhCt2m.png" alt="gc日志规律.png"></p>
<p>Minor GC:</p>
<p><img src="https://i.loli.net/2019/10/21/WoRFtbkTN3EqlfM.png" alt="Minor GC日志.png"></p>
<p>Full GC:</p>
<p><img src="https://i.loli.net/2019/10/21/duWEjiF6B3OvZTx.png" alt="Full GC1.png"></p>
<p><img src="https://i.loli.net/2019/10/21/X3sgSkhRpvoB5UA.png" alt="Full GC2.png"></p>
<h2 id="9-GC"><a href="#9-GC" class="headerlink" title="9.GC"></a>9.GC</h2><h3 id="GC是什么"><a href="#GC是什么" class="headerlink" title="GC是什么?"></a>GC是什么?</h3><p>分代收集算法:</p>
<p>次数频繁收集:Young区—Minor GC</p>
<p>次数上较少收集:Old区—Full GC</p>
<p>基本不动:元空间(java8以后)</p>
<p><strong>Full GC的速度一般要比Minor GC慢上10倍以上</strong></p>
<h3 id="四大算法"><a href="#四大算法" class="headerlink" title="四大算法"></a>四大算法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p><img src="https://i.loli.net/2019/10/21/nadQpM9WY2CK8Os.png" alt="引用计数法.png"></p>
<p>当引用计数为0时,回收对象</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><strong>年轻代</strong>中使用的是Minor GC,这种GC采用的是复制算法(Copying)</p>
<p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中,如果Survivor区中放不下,那么剩下的活的对象就被移到Old区中,也就是一旦收集后,Eden就变成了空的了.</p>
<p>​    当对象在Eden(包括From区)出生后,在经过一次Minor GC后,如果对象还存活,并且能够被To区所容纳,则使用<strong>复制算法</strong>将这些仍然存活的对象复制到To区中,然后清理所使用过的Eden和From区,并且将这些对象的年龄设置为1,以后对象在幸存区每熬过一次Minor GC,就将对象年龄+1,当对象15岁(默认)时,这些对象就会成为老年代</p>
<p>-XX:MaxTenuringThreshold -设置对象在新生代中存活的次数(不能超过15)</p>
<p>复制算法的基本思想就是将内存分为两块,每次只用其中一块,当这一块内存用完,就将还活着的对象复制到另外一块上面.</p>
<p><img src="https://i.loli.net/2019/10/21/49EQ7azyYJmcRHC.png" alt="复制算法.png"></p>
<p><strong>优点:不会产生内存碎片</strong></p>
<p><strong>缺点:浪费一半内存</strong></p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>老年代一般是由标记清除或者是标记清除与标记整理混合使用</p>
<p>算法分成标记和清除两个阶段,先标记出要回收的对象,然后统一回收这些对象.</p>
<p><strong>优点:不需要额外空间</strong></p>
<p><strong>缺点:两次扫描,耗时严重;会产生内存碎片</strong></p>
<h4 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h4><p>发生在老年代,标记清除与标记整理混合使用</p>
<p><strong>优点:没有内存碎片</strong></p>
<p><strong>缺点:扫描2次,需要移动对象的成本</strong></p>
<h2 id="10-JMM-Java内存模型"><a href="#10-JMM-Java内存模型" class="headerlink" title="10.JMM(Java内存模型)"></a>10.JMM(Java内存模型)</h2><p>JMM本身是一种抽象的概念<strong>并不真实存在</strong>,它描述的是一组规则或规范,通过这组规范定义了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.</p>
<p><strong>特征:</strong></p>
<p><strong>可见性(通知机制,两个线程操纵同一个值,A线程内存的值改了,B线程要马上收到通知)</strong></p>
<p><strong>给那个值加上volatile关键字,就建立了通知机制</strong></p>
<p><strong>原子性,</strong></p>
<p><strong>有序性</strong></p>
<p>由于JVM运行程序的实体是线程,而每个线程创建时都会为其创建一个工作内存(有些地方称为栈空间),工作内存是每个线程私有的数据区域,而Java内存模型中规定所有变量都存储在<strong>主内存</strong>,主内存是共享内存区域,所有的线程都可以访问,<strong>但线程对变量的操作(读写等)必须在工作内存中进行,首先将变量从主内存拷贝到线程自己的工作空间,然后对变量进行操作,操作完成后再将变量写回主内存,</strong>不能直接操作主内存中的变量,各线程的工作内存中存储着主内存中的<strong>变量副本拷贝</strong>,因此不同的线程间无法访问对方的工作内存,线程间的通信(传值)必须通过主内存来完成,其简要访问过程如下图:</p>
<p><img src="https://i.loli.net/2019/10/29/67N2YpXOwfTCqGz.png" alt="JMM.png"></p>
<h2 id="小面试题"><a href="#小面试题" class="headerlink" title="小面试题:"></a>小面试题:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeKobe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeKobe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeKobe的构造方法1111111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeKobe的构造块222222222222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeKobe的静态代码块3333333333"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlock</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeBlock的构造块4444444444444444"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeBlock的静态代码块5555555555555"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CodeBlock的构造方法6666666666666"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> CodeKobe();</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> CodeKobe();</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> CodeBlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CodeBlock的静态代码块<span class="number">5555555555555</span></span><br><span class="line">------------------------------</span><br><span class="line">CodeKobe的静态代码块<span class="number">3333333333</span></span><br><span class="line">CodeKobe的构造块<span class="number">222222222222</span></span><br><span class="line">CodeKobe的构造方法<span class="number">1111111111</span></span><br><span class="line">------------------------------</span><br><span class="line">CodeKobe的构造块<span class="number">222222222222</span></span><br><span class="line">CodeKobe的构造方法<span class="number">1111111111</span></span><br><span class="line">------------------------------</span><br><span class="line">CodeBlock的构造块<span class="number">4444444444444444</span></span><br><span class="line">CodeBlock的构造方法<span class="number">6666666666666</span></span><br></pre></td></tr></table></figure>

<p><strong>要点:</strong></p>
<p><strong>静态块&gt;构造块&gt;构造方法</strong></p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>关于juc的一些基础</title>
    <url>/2019/10/20/%E5%85%B3%E4%BA%8Ejuc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-JUC-java-util-concurrent"><a href="#1-JUC-java-util-concurrent" class="headerlink" title="1.  JUC-(java.util.concurrent)"></a>1.  JUC-(java.util.concurrent)</h2><h3 id="1-1-进程-线程"><a href="#1-1-进程-线程" class="headerlink" title="1.1 进程/线程"></a>1.1 进程/线程</h3><h3 id="1-2-并发-并行"><a href="#1-2-并发-并行" class="headerlink" title="1.2 并发/并行"></a>1.2 并发/并行</h3><h2 id="2-三个包"><a href="#2-三个包" class="headerlink" title="2. 三个包"></a>2. 三个包</h2><ul>
<li><a href="java/util/concurrent/package-frame.html">java.util.concurrent</a>  </li>
<li><a href="java/util/concurrent/atomic/package-frame.html">java.util.concurrent.atomic</a>  </li>
<li><a href="java/util/concurrent/locks/package-frame.html">java.util.concurrent.locks</a> </li>
</ul><h4 id="线程的状态分类"><a href="#线程的状态分类" class="headerlink" title="线程的状态分类:"></a>线程的状态分类:</h4><p>1.NEW(初始)– 新创建了一个线程对象，但还没有调用start()方法。 </p><a id="more"></a>

<p>2.RUNNABLE(运行)–就绪</p>
<p>3.BLOCKED(阻塞)</p>
<p>4.WAITING(等待)–死等,不见不散</p>
<p>5.TIMED_WAITING(超时等待)–过时不候</p>
<p>6.TREMINATED(终止)– 表示该线程已经执行完毕。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;<span class="comment">//资源类=实例变量+实例方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//List list = new ArrayList();(左接口,右实现)</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"\t卖出第: "</span>+(number--)+<span class="string">"\t 还剩下: "</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目:三个售票员,   卖出  30帐篷</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 笔记:编写企业级的多线程代码</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1.在高内聚低耦合的前提下,线程     操作     资源类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 1.1 先创建一个资源类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//主线程</span></span><br><span class="line">        <span class="comment">//资源</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                for (int i = 1; i &lt;= 40; i++) &#123;</span></span><br><span class="line"><span class="comment">                    ticket.sale();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, "A").start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                for (int i = 1; i &lt;= 40; i++) &#123;</span></span><br><span class="line"><span class="comment">                    ticket.sale();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, "B").start();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                for (int i = 1; i &lt;= 40; i++) &#123;</span></span><br><span class="line"><span class="comment">                    ticket.sale();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, "C").start();*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//public void sayHello();</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.函数式编程</span></span><br><span class="line"><span class="comment"> * int age = 25;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * y = kx + 1;</span></span><br><span class="line"><span class="comment"> * ↓</span></span><br><span class="line"><span class="comment"> * f(x) = kx + 1;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * lambda步骤:</span></span><br><span class="line"><span class="comment"> * 1.拷贝小括号,写死右箭头,落地大括号</span></span><br><span class="line"><span class="comment"> * 2.函数式接口---只有一个方法</span></span><br><span class="line"><span class="comment"> * 3.default(可多个)</span></span><br><span class="line"><span class="comment"> * 4.static(可多个)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExpressDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Foo foo = new Foo() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void sayHello() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("hello lambda");</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int add(int x, int y) &#123;</span></span><br><span class="line"><span class="comment">                return 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; ;</span></span><br><span class="line"><span class="comment">        foo.sayHello();*/</span></span><br><span class="line"></span><br><span class="line">        Foo foo = (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"come in add method"</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo.add(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(foo.mul(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(Foo.div(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-集合类不安全"><a href="#4-集合类不安全" class="headerlink" title="4. 集合类不安全"></a>4. 集合类不安全</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList默认容量10,类型为Object的数组</span><br><span class="line">容量满后,1.5倍扩容,底层使用Array.copyOf()进行拷贝(10-&gt;15-&gt;22)</span><br><span class="line">PS:HashMap默认容量16,2倍扩容(16-&gt;32)</span><br></pre></td></tr></table></figure>

<p><strong>ArrayList是线程不安全的</strong></p>
<p>1.故障现象: java.util.ConcurrentModificationException 并发修改异常</p>
<p>2.导致原因: 多线程并发争抢同一个资源类,没加锁</p>
<p>3.解决方法</p>
<p>​    3.1 加锁(Vector)</p>
<p>​    3.2 Collections.synchronizedList(new ArrayList&lt;&gt;());</p>
<p>​    3.3 new CopyOnWriteArrayList&lt;&gt;();–写时复制</p>
<p><strong>写时复制</strong>:</p>
<p>CopyOnWrite容器即写时复制的容器,往一个容器添加元素的时候,不直接往当前容器Object[]添加,而是将当前容器进行copy,复制出一个新的Object[] newElements,然后新的容器Object[] newElements里添加元素,添加完元素后再将原容器的引用指向新的容器setArray(newElements);这样做的好处是可以对CopyOnWrite容器进行并发的读,而不需要加锁,因为当前容器不会添加任何元素,所以CopyOnWrite容器也是一种读写分离的思想,读和写不同的容器.</p>
<p><strong>部分源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>另外,list,set,map都是线程不安全的,解决方法与写时复制一样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSafeDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        mapNotSafe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapNotSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(); <span class="comment">//new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setNotSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;(); <span class="comment">//new HashSet&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listNotSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="comment">//Collections.synchronizedList(new ArrayList&lt;&gt;()); //new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-八种锁"><a href="#5-八种锁" class="headerlink" title="5. 八种锁"></a>5. 八种锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//TimeUnit.SECONDS.sleep(4);</span></span><br><span class="line">        System.out.println(<span class="string">"*****sendEmail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****sendSMS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****sayHello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock8Demo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">                <span class="comment">//phone.sayHello();</span></span><br><span class="line">                <span class="comment">//phone2.sendSMS();</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前提:资源类手机.两个同步方法,一个发邮件,一个发信息,开启两个线程去调用这两个方法</p>
<p> <strong>锁1.标准访问(两个同步方法),请问先打印邮件还是短信   邮件</strong></p>
<p> <strong>锁2.暂停4秒钟,再邮件方法,请问先打印邮件还是短信    邮件</strong></p>
<p><strong>原因:</strong></p>
<p>一个对象里面如果有多个sychronized方法,某一个时刻内,只要一个线程去调用其中的一个sychronized方法了,其他线程都只能等待,换句话说,某一个时刻内,只能有唯一一个线程去访问这些sychronized方法</p>
<p><strong>锁的是当前对象this,被锁定后,其他的线程都不能进入到当前对象的其他的sychronized方法</strong></p>
<p> <strong>锁3.新增普通sayHello方法,请问先打印邮件(暂停4秒)还是hello  hello</strong></p>
<p><strong>原因:</strong></p>
<p>加个普通方法后发现和同步锁无关</p>
<p> <strong>锁4.两部手机,先打印邮件还是短信 短信</strong></p>
<p><strong>原因:</strong></p>
<p>换成两个对象后,不是同一把锁了,情况不一样</p>
<p> <strong>锁5.两个静态同步方法,同一部手机,请问先打印邮件(暂停4秒)还是短信 邮件</strong></p>
<p> <strong>锁6.两个静态同步方法,两部手机,请问先打印邮件(暂停4秒)还是短信  邮件</strong></p>
<p><strong>原因:</strong></p>
<p>sychronized实现同步的基础:Java中的每一个对象都可以作为锁.</p>
<p>具体表现为以下3中形式</p>
<p>对于普通同步方法,锁是当前实例对象</p>
<p>对于同步方法块,锁是sychronized括号里配置的对象</p>
<p><strong>对于静态同步方法,锁是当前类的Class对象</strong></p>
<p>  <strong>锁7.一个静态同步方法,一个普通同步方法,同一部手机,请问先打印邮件(暂停4秒)还是短信    短信</strong></p>
<p>  <strong>锁8.一个静态同步方法,一个普通同步方法,两部手机,请问先打印邮件(暂停4秒)还是短信 短信</strong></p>
<p><strong>原因:</strong></p>
<p>锁7的情况是,静态同步方法锁的是当前类Class对象,普通同步方法锁的是当前实例对象this,不是通一把锁</p>
<p>锁8情况类似,一个锁是类对象,一个锁是实例对象,不是通一把锁</p>
<p> 总结:</p>
<p>​    当一个线程试图访问同步代码块时,它首先必须得到锁,退出或抛出异常时必须释放锁.</p>
<p>​    也就是说如果一个实例对象的非静态同步方法获取锁后,该实例对象的其他非静态方法必须等待获取锁的方法释放锁后才能获取锁</p>
<p>​    可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁,所以无需等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁</p>
<p>​    <strong>所有静态同步方法用的是通一把锁—–类对象本身(Class)</strong></p>
<p>这两把锁是两个不同的对象,所以静态同步方法与非静态同步方法之间是不会有竞态条件的.</p>
<p>但是一旦一个静态同步方法获取锁后,其他的静态同步方法都必须等待该方法释放锁后才能获取锁.</p>
<p>而不管是同一个实例对象的静态同步方法之间,还是不同实例对象的静态同步方法之间,只要它们同一个类的实例对象</p>
<h2 id="6-多线程—生产者消费者"><a href="#6-多线程—生产者消费者" class="headerlink" title="6. 多线程—生产者消费者"></a>6. 多线程—生产者消费者</h2><p>(老版本:synchronize   新版本:lock)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aircondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            <span class="comment">//this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//this.wait();</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span>+num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            <span class="comment">//this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老版本:synchronize</span></span><br><span class="line">    <span class="comment">/*public synchronized void increment() throws Exception &#123;</span></span><br><span class="line"><span class="comment">        //1.判断</span></span><br><span class="line"><span class="comment">        while (num != 0) &#123;</span></span><br><span class="line"><span class="comment">            this.wait();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //2.干活</span></span><br><span class="line"><span class="comment">        num++;</span></span><br><span class="line"><span class="comment">        System.out.println(Thread.currentThread().getName() + "\t"+num);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //3.通知</span></span><br><span class="line"><span class="comment">        this.notifyAll();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public synchronized void decrement() throws Exception &#123;</span></span><br><span class="line"><span class="comment">        //1.判断</span></span><br><span class="line"><span class="comment">        while (num == 0) &#123;</span></span><br><span class="line"><span class="comment">            this.wait();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //2.干活</span></span><br><span class="line"><span class="comment">        num--;</span></span><br><span class="line"><span class="comment">        System.out.println(Thread.currentThread().getName() + "\t"+num);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //3.通知</span></span><br><span class="line"><span class="comment">        this.notifyAll();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目:现在两个线程,可以操作初始值为零的一个变量</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1,一个线程对该变量减1</span></span><br><span class="line"><span class="comment"> * 实现交替,来10轮,变量初始值为零</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.高内聚低耦合,线程操作资源类</span></span><br><span class="line"><span class="comment"> * 2.判断+干活+通知</span></span><br><span class="line"><span class="comment"> * 3.防止线程的虚假唤醒,只要有wait需要用while判断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 知识小结---多线程编程套路+while判断+新版写法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Aircondition aircondition = <span class="keyword">new</span> Aircondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"D"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/10/20/jmI1k4ZX9xegVWc.png" alt="lock.png"></p>
<h2 id="7-Condition–精确唤醒"><a href="#7-Condition–精确唤醒" class="headerlink" title="7. Condition–精确唤醒"></a>7. Condition–精确唤醒</h2><p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;<span class="comment">//A:1  B:2  C:3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) &#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备注:多线程之间按顺序调用,实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动,要求如下:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AA打印5次,BB打印10次,CC打印15次</span></span><br><span class="line"><span class="comment"> * go on</span></span><br><span class="line"><span class="comment"> * AA打印5次,BB打印10次,CC打印15次</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 10轮</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print5();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print10();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print15();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Callable—有返回值的线程操作方法"><a href="#8-Callable—有返回值的线程操作方法" class="headerlink" title="8. Callable—有返回值的线程操作方法"></a>8. Callable—有返回值的线程操作方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****come in call method()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread());<span class="comment">//构造方法参数:可传callable or runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Integer result = futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-countDownLatch"><a href="#9-countDownLatch" class="headerlink" title="9.countDownLatch"></a>9.countDownLatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.com.kobe.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有6个同学在体育馆打篮球,管理员main要等6个人离开球馆后才能关灯闭馆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t离开球场"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t关灯闭馆"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t离开球场"</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t关灯闭馆"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CountDownLatch主要有两个方法,当一个或多个线程调用await方法时,这些线程会阻塞</li>
<li>其他线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</li>
<li>当计数器的值变为0时,因await方法阻塞的线程会被唤醒,继续执行.</li>
</ul>
<h2 id="10-CyclicBarrier"><a href="#10-CyclicBarrier" class="headerlink" title="10.CyclicBarrier"></a>10.CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.com.kobe.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"\t收集到第"</span>+temp+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-Semaphore"><a href="#11-Semaphore" class="headerlink" title="11.Semaphore"></a>11.Semaphore</h2><p>信号灯:</p>
<p>在信号量上我们定义两种操作:</p>
<ul>
<li>acquire(获取):当一个线程调用acquire操作时,它要么通过成功获取信号量(信号量减1),要么一直等下去,直到有线程释放信号量,或超时</li>
<li>release(释放):实际上会将信号量的值加1,然后唤醒等待的线程</li>
</ul>
<p><strong>信号量主要用于两个目的,一个是用于多个共享资源的互斥使用,另一个用于并发线程数的控制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.com.kobe.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟资源类,有3个空车位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6部车抢3个车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//占用,车位-1</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t抢到了车位"</span>);</span><br><span class="line">                    <span class="comment">//抢到车位后,停3秒就走</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t离开了车位"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放,车位+1</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-ReadWriteLock"><a href="#12-ReadWriteLock" class="headerlink" title="12.ReadWriteLock"></a>12.ReadWriteLock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.com.kobe.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t开始写入"</span>);</span><br><span class="line">            <span class="comment">//暂停一会线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t写入完成"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t开始读取"</span>);</span><br><span class="line">            <span class="comment">//暂停一会线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t读取完成"</span> + <span class="string">"\t"</span>+o);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没问题,所以为了满足并发量,读取共享资源应该可以同时进行</span></span><br><span class="line"><span class="comment"> *但是如果有一个线程想去写共享资源类,就不能有其他线程可以对该资源进行读写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *总结:</span></span><br><span class="line"><span class="comment"> *  读-读共存</span></span><br><span class="line"><span class="comment"> *  读-写不能共存</span></span><br><span class="line"><span class="comment"> *  写-写不能共存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.put(temp +<span class="string">""</span>,temp + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.get(temp +<span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-BlockingQueue"><a href="#13-BlockingQueue" class="headerlink" title="13.BlockingQueue"></a>13.BlockingQueue</h2><p><img src="https://i.loli.net/2019/10/29/yKmwuNZICka5V6A.png" alt="阻塞队列.png"></p>
<p>当队列是空的,从队列中<strong>获取</strong>元素的操作将会被阻塞</p>
<p>当队列是满的,从队列中<strong>添加</strong>元素的操作将会被阻塞</p>
<p>在多线程领域:所谓阻塞,在某些情况下会<strong>挂起</strong>线程(即阻塞),一旦条件满足,被挂起的线程又会自动被<strong>唤起</strong></p>
<p>为什么需要BlockingQueue?</p>
<p>好处是我们不需要关心什么时候需要阻塞线程,什么时候需要唤醒线程,因为这一切BlockingQueue都会一首操办</p>
<p>种类:</p>
<p>ArrayBlockingQueue:由数组结构组成的有界阻塞队列</p>
<p>LinkedBlockingQueue:由链表结构组成的有界阻塞队列</p>
<p>SynchronousQueue:不存储元素的阻塞队列,也即单个元素的队列</p>
<table>
<thead>
<tr>
<th align="center">方法类型</th>
<th align="center">抛出异常</th>
<th align="center">特殊值</th>
<th align="center">阻塞</th>
<th align="center">超时</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">add(e)</td>
<td align="center">offer()</td>
<td align="center">put(e)</td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不可用</td>
<td align="center">不可用</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">抛出异常</th>
<th>当阻塞队列满时,再往队列里add插入元素会抛IllegalStateException: Queue full<br>当阻塞队列空时,再往队列里remove移除元素会抛NoSuchElementException</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>特殊值</strong></td>
<td>插入方法,成功返回true失败返回false<br> 移除方法,成功返回出队列的元素,队列里没有就返回null</td>
</tr>
<tr>
<td align="left"><strong>一直阻塞</strong></td>
<td>当阻塞队列满时,生产者线程继续往队列里put元素,队列会一直阻塞生产者线程知道put数据or响应中断退出<br>当阻塞队列空时,消费者线程试图从队列里take元素,队列会一直阻塞消费者线程知道队列可用</td>
</tr>
<tr>
<td align="left"><strong>超时退出</strong></td>
<td>当阻塞队列满时,队列会阻塞生产者线程一定时间,超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h2 id="14-题-TransferValue"><a href="#14-题-TransferValue" class="headerlink" title="14.题-TransferValue"></a>14.题-TransferValue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransferValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.setPersonName(<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValue3</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"xxx"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestTransferValue test = <span class="keyword">new</span> TestTransferValue();</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(<span class="string">"age---"</span> + age);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"kobe"</span>);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(<span class="string">"personName-----"</span> + person.getPersonName());</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"kobe"</span>;</span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(<span class="string">"String---"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">age---<span class="number">20</span></span><br><span class="line">personName-----xxx</span><br><span class="line">String---kobe</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>传基本类型时,值不会变</p>
<p>传自定义的引用类型,值会改变</p>
<p>传字符串,值不会变</p>
<h2 id="15-线程池"><a href="#15-线程池" class="headerlink" title="15.线程池"></a>15.线程池</h2><h3 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势:"></a>线程池的优势:</h3><p>​    线程池做的工作只要是控制运行的线程数量,<strong>处理过程中将任务放入队列</strong>,然后在线程创建后启动这些任务,<strong>如果线程数量超过了最大数量,超出数量的线程排队等候</strong>,等其他线程执行完毕,再从队列中取出任务来执行.</p>
<p><strong>它的主要特点为:线程复用;控制最大并发数;管理线程</strong></p>
<p>主要的三种API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一池5个工作线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//一池1个工作线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//一池n个工作线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<p>源码:</p>
<p><img src="https://i.loli.net/2019/10/29/I9aoNVxmlbSJAG7.png" alt="线程池源码.png"></p>
<h3 id="线程池的几个重要参数-面试"><a href="#线程池的几个重要参数-面试" class="headerlink" title="线程池的几个重要参数(面试)"></a>线程池的几个重要参数(面试)</h3><p>源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7大参数"><a href="#7大参数" class="headerlink" title="7大参数:"></a>7大参数:</h4><ol>
<li>corePoolSize:线程池中的常驻核心线程数</li>
<li>maximumPoolSize:线程池中能够容纳同时执行的最大线程数,此值必须大于等于1</li>
<li>keepAliveTime:多余的空闲线程的存活时间,当前池中线程数量超过corePoolSize时,当空闲时间达到keepAliveTime时,多余线程会被销毁直到只剩下corePoolSize为之</li>
<li>unit:keepAliveTime的单位</li>
<li>workQueue:任务队列,被提交但尚未被执行的任务</li>
<li>threadFactory:表示生成线程池中工作线程的线程工厂,用于创建线程,<strong>一般默认的即可</strong></li>
<li>handler:拒绝策略,表示当队列满了,并且工作线程大于等于线程池的最大线程数时如何来拒绝请求执行的Runnable的策略</li>
</ol>
<h3 id="底层工作原理"><a href="#底层工作原理" class="headerlink" title="底层工作原理"></a>底层工作原理</h3><p><img src="https://i.loli.net/2019/10/29/b5Ej6kBspUwzR8i.png" alt="线程池工作流程.png"></p>
<ol>
<li>在创建了线程池后,开始等待请求</li>
<li>当调用execute()方法添加一个请求任务时,线程池会做出如下判断:<ol>
<li>如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize,那么将这个任务<strong>放入阻塞队列</strong></li>
<li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize,创建非核心线程立刻运行这个任务</li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会<strong>启动饱和拒绝策略来执行</strong></li>
</ol>
</li>
<li>当一个线程完成任务时,它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做超过一定的时间(keepAliveTime)时,判断<ol>
<li>如果当前运行的线程数大于corePoolSize,那么这个线程会被停掉,所以最后所有任务完成后,线程池会<strong>收缩成corePoolSize的大小</strong></li>
</ol>
</li>
</ol>
<h3 id="jdk内置的拒绝策略"><a href="#jdk内置的拒绝策略" class="headerlink" title="jdk内置的拒绝策略"></a>jdk内置的拒绝策略</h3><ol>
<li>AbortPolicy(默认):直接抛出RejectedExecutionException异常阻止系统正常运行</li>
<li>CallerRunsPolicy:”调用者运行”一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者,从而降低新任务的流量</li>
<li>DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交当前任务</li>
<li>DiscardPolicy:该策略默默地丢弃无法处理的任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种策略</li>
</ol>
<p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//看内核数</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,<span class="comment">//常驻核心数</span></span><br><span class="line">                Runtime.getRuntime().availableProcessors() + <span class="number">1</span>,<span class="comment">//最大线程一般设为内核数+1</span></span><br><span class="line">                <span class="number">2</span>,<span class="comment">//多余线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//存活时间单位</span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),<span class="comment">//阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">//线程工厂,使用默认</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());<span class="comment">//拒绝策略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟10个顾客来银行办理业务,目前池子里面有5个工作人员提供服务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"\t办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一池5个工作线程</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool = Executors.newFixedThreadPool(5);</span></span><br><span class="line">        <span class="comment">//一池1个工作线程</span></span><br><span class="line">        <span class="comment">//ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">//一池n个工作线程</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟10个顾客来银行办理业务,目前池子里面有5个工作人员提供服务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"\t办理业务"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//暂停一会线程</span></span><br><span class="line">                <span class="comment">//try &#123; TimeUnit.MILLISECONDS.sleep(400); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-流式计算"><a href="#16-流式计算" class="headerlink" title="16.流式计算"></a>16.流式计算</h2><h4 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h4><p> Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。 </p>
<p> Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。 </p>
<p>Lombok的使用跟引用jar包一样，可以在官网（<a href="https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：" target="_blank" rel="noopener">https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p>
<h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter"></a>@Getter/@Setter</h4><p>如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法</p>
<h4 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h4><p>该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。</p>
<h4 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h4><p>该注解能帮助我们自动调用close()方法，很大的简化了代码。</p>
<h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h4><p>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。</p>
<h4 id="NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor"></a>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h4><p>无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</p>
<h4 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h4><p>生成equals()方法和hashCode方法</p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h4><p>同步方法</p>
<h3 id="java内置核心四大函数式接口"><a href="#java内置核心四大函数式接口" class="headerlink" title="java内置核心四大函数式接口:"></a>java内置核心四大函数式接口:</h3><p><img src="https://i.loli.net/2019/10/29/MPgvsYB4VzXG5F1.png" alt="四大函数式接口.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String,Integer&gt; function = s -&gt; &#123;<span class="keyword">return</span> s.length();&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate = s -&gt; &#123;<span class="keyword">return</span> s.isEmpty();&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">"kobe"</span>));</span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer = s -&gt; &#123; System.out.println(s); &#125;;</span><br><span class="line">consumer.accept(<span class="string">"kobe"</span>);</span><br><span class="line"></span><br><span class="line">Supplier&lt;String&gt; supplier = () -&gt; &#123;<span class="keyword">return</span> <span class="string">"kobe"</span>;&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">kobe</span><br><span class="line">kobe</span><br></pre></td></tr></table></figure>

<h3 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么?"></a>Stream是什么?</h3><p>是数据渠道,用于操作数据源(集合,数组等)所生成的元素序列</p>
<p><strong>“集合讲的是数据,流讲的是计算”</strong></p>
<h3 id="Stream的特点"><a href="#Stream的特点" class="headerlink" title="Stream的特点"></a>Stream的特点</h3><ol>
<li>Stream自己不会存储元素</li>
<li>Stream不会改变源对象,相反,他们会返回一个持有结果的新的Stream</li>
<li>Stream操作是延迟执行的.这意味着他们会等到需要结果的时候才执行</li>
</ol>
<h3 id="Stream怎么玩"><a href="#Stream怎么玩" class="headerlink" title="Stream怎么玩?"></a>Stream怎么玩?</h3><ul>
<li>创建一个Stream:一个<strong>数据源</strong>(数组,集合)</li>
<li>中间操作:一个中间操作,<strong>处理</strong>数据源数据</li>
<li>终止操作:一个终止操作,<strong>执行</strong>中间操作链,产生结果</li>
</ul>
<p><strong>源头-&gt;中间流水线-&gt;结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题:按照给出的数据,找出同时满足以下条件的用户,也即以下条件全部满足</span></span><br><span class="line"><span class="comment"> *    偶数id</span></span><br><span class="line"><span class="comment"> *    且年龄大于24</span></span><br><span class="line"><span class="comment"> *    且用户名转为大写</span></span><br><span class="line"><span class="comment"> *    且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *    且只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        list.stream().filter(u -&gt; &#123;<span class="keyword">return</span> u.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(u -&gt; &#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">24</span>;</span><br><span class="line">        &#125;).map(m -&gt; &#123;<span class="keyword">return</span> m.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;<span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*List&lt;User&gt; users = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (User user : list) &#123;</span></span><br><span class="line"><span class="comment">            if (user.getId() % 2 == 0 &amp;&amp; user.getAge() &gt; 24) &#123;</span></span><br><span class="line"><span class="comment">                user.setUserName(user.getUserName().toUpperCase());</span></span><br><span class="line"><span class="comment">                users.add(user);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(users.get(users.size() - 1).getUserName());*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<h2 id="17-分支合并框架-ForkJoin"><a href="#17-分支合并框架-ForkJoin" class="headerlink" title="17.分支合并框架(ForkJoin)"></a>17.分支合并框架(ForkJoin)</h2><p>Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= ADJUST_VALUE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (end + begin)/<span class="number">2</span>;</span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin,middle);</span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result = task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*计算0-1000的和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = threadPool.submit(myTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-异步回调"><a href="#18-异步回调" class="headerlink" title="18.异步回调"></a>18.异步回调</h2><p> Demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"没有返回---操作数据库"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        completableFuture.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"没有返回"</span>);</span><br><span class="line">            <span class="comment">//int age = 10/0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture2.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"******t:"</span> + t);</span><br><span class="line">            System.out.println(<span class="string">"******u:"</span> + u);</span><br><span class="line">        &#125;).exceptionally(f -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"***exception"</span> + f.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>没有返回---操作数据库</span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>没有返回</span><br><span class="line">******t:<span class="number">1024</span></span><br><span class="line">******u:<span class="keyword">null</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line">    </span><br><span class="line">如果打开<span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>没有返回---操作数据库</span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>没有返回</span><br><span class="line">******t:<span class="keyword">null</span></span><br><span class="line">******u:java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">***exceptionjava.lang.ArithmeticException: / by zero</span><br><span class="line"><span class="number">444</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot中的content-path问题</title>
    <url>/2019/10/14/springboot%E4%B8%AD%E7%9A%84content-path%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 今天在yml配置中设置了server.context-path,运行起来后发现不生效;</p>
<p>不生效的原因:原来spring boot2.0之后，上下文的配置改为了server.servlet.context-path </p>
<p><code>server.servlet.context-path=/boot</code></p>
]]></content>
      <categories>
        <category>坑</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>YML基本语法</title>
    <url>/2019/10/13/YML%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="YML语法："><a href="#YML语法：" class="headerlink" title="YML语法："></a>YML语法：</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2、值的写法"><a href="#2、值的写法" class="headerlink" title="2、值的写法"></a>2、值的写法</h3><h4 id="字面量：普通的值（数字，字符串，布尔）"><a href="#字面量：普通的值（数字，字符串，布尔）" class="headerlink" title="字面量：普通的值（数字，字符串，布尔）"></a>字面量：普通的值（数字，字符串，布尔）</h4><pre><code>k: v：字面直接来写；

    字符串默认不用加上单引号或者双引号；

    &quot;&quot;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思

            name:   &quot;zhangsan \n lisi&quot;：输出；zhangsan 换行  lisi

    &apos;&apos;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据

            name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</code></pre><a id="more"></a>




<h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><pre><code>k: v：在下一行来写对象的属性和值的关系；注意缩进

    对象还是k: v的方式</code></pre><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">		<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">		<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>

<p>行内写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure>

<h2 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h2><p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">    boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">    maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">    lists:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">    dog:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>javaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1、-Value获取值和-ConfigurationProperties获取值比较"><a href="#1、-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="1、@Value获取值和@ConfigurationProperties获取值比较"></a>1、@Value获取值和@ConfigurationProperties获取值比较</h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<h4 id="2、配置文件注入值数据校验"><a href="#2、配置文件注入值数据校验" class="headerlink" title="2、配置文件注入值数据校验"></a>2、配置文件注入值数据校验</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<h4 id="3、-PropertySource-amp-ImportResource-amp-Bean"><a href="#3、-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3、@PropertySource&amp;@ImportResource&amp;@Bean"></a>3、@PropertySource&amp;@ImportResource&amp;@Bean</h4><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure>

<p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure>

<p>不来编写Spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p>
<p>2、使用<strong>@Bean</strong>给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>yml</tag>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA</title>
    <url>/2019/10/12/Spring-Data-JPA/</url>
    <content><![CDATA[<h1 id="一-ORM思想"><a href="#一-ORM思想" class="headerlink" title="一.ORM思想"></a>一.ORM思想</h1><h2 id="主要目的-操作实体类就相当于操作数据库表"><a href="#主要目的-操作实体类就相当于操作数据库表" class="headerlink" title="主要目的:操作实体类就相当于操作数据库表"></a>主要目的:操作实体类就相当于操作数据库表</h2><pre><code>建立两个映射关系:
    实体类和表的映射关系
    实体类中属性和表中字段的映射关系
建立完成后,不再重点关注sql语句

实现了ORM思想的框架:mybatis,hibernate</code></pre><h1 id="二-hibernate框架介绍"><a href="#二-hibernate框架介绍" class="headerlink" title="二.hibernate框架介绍"></a>二.hibernate框架介绍</h1><h3 id="Hibernate是一个开放源代码的对象关系映射框架"><a href="#Hibernate是一个开放源代码的对象关系映射框架" class="headerlink" title="Hibernate是一个开放源代码的对象关系映射框架"></a>Hibernate是一个开放源代码的对象关系映射框架</h3><a id="more"></a><h3 id="它对JDBC进行了非常轻量级的对象封装"><a href="#它对JDBC进行了非常轻量级的对象封装" class="headerlink" title="它对JDBC进行了非常轻量级的对象封装"></a>它对JDBC进行了非常轻量级的对象封装</h3><h3 id="它将POJO与数据库表建立映射关系，是一个全自动的orm框架"><a href="#它将POJO与数据库表建立映射关系，是一个全自动的orm框架" class="headerlink" title="它将POJO与数据库表建立映射关系，是一个全自动的orm框架"></a>它将POJO与数据库表建立映射关系，是一个全自动的orm框架</h3><h3 id="hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。"><a href="#hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。" class="headerlink" title="hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。"></a>hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</h3><h1 id="三-JPA规范"><a href="#三-JPA规范" class="headerlink" title="三.JPA规范"></a>三.JPA规范</h1><pre><code>jap规范,内部是由接口和抽象类组成的</code></pre><p>JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成  </p>
<p>JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<h2 id="JPA的优势"><a href="#JPA的优势" class="headerlink" title="JPA的优势"></a>JPA的优势</h2><ol>
<li><p>标准化<br>JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。</p>
</li>
<li><p>容器级特性的支持<br>JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。</p>
</li>
<li><p>简单方便<br>JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成</p>
</li>
<li><p>查询能力<br>JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</p>
</li>
<li><p>高级特性<br>JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。</p>
</li>
</ol>
<h2 id="JPA与hibernate的关系"><a href="#JPA与hibernate的关系" class="headerlink" title="JPA与hibernate的关系"></a>JPA与hibernate的关系</h2><p><img src="https://i.loli.net/2019/10/12/g2SG3C6qxj7BIzs.png" alt="1.png"></p>
<p>JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。</p>
<h1 id="四-JPA的基本操作"><a href="#四-JPA的基本操作" class="headerlink" title="四.JPA的基本操作"></a>四.JPA的基本操作</h1><h2 id="搭建环境的过程"><a href="#搭建环境的过程" class="headerlink" title="搭建环境的过程"></a>搭建环境的过程</h2><h3 id="创建maven工程导入坐标"><a href="#创建maven工程导入坐标" class="headerlink" title="创建maven工程导入坐标"></a>创建maven工程导入坐标</h3><pre><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;!-- junit --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- hibernate对jpa的支持包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
        &lt;version&gt;${project.hibernate.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- c3p0 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;
        &lt;version&gt;${project.hibernate.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- log日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Mysql and MariaDB --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.6&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h3 id="配置jpa的核心配置文件"><a href="#配置jpa的核心配置文件" class="headerlink" title="配置jpa的核心配置文件"></a>配置jpa的核心配置文件</h3><p>位置:配置到类路径下的一个叫做META-INF的文件夹下<br>命名:persistence.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt;
    &lt;!--需要配置persistence-unit节点
        持久化单元:
            name:持久化单元名称
            transaction-type:事务管理的方式
                JTA:分布式事务管理
                RESOURCE_LOCAL:本地事务管理
    --&gt;
    &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;!--jpa的实现方式--&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;

        &lt;!--可选配置:配置jpa实现方的配置信息--&gt;
        &lt;properties&gt;
            &lt;!--数据库信息
                用户名:javax.persistence.jdbc.user
                密码:javax.persistence.jdbc.password
                驱动:javax.persistence.jdbc.driver
                数据库地址:javax.persistence.jdbc.url
            --&gt;
            &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql:///jpa&quot;/&gt;

            &lt;!--配置jpa实现方(hibernate)的配置信息
                显示sql:          hibernate.show_sql   false|true
                自动创建数据库表:   hibernate.hbm2ddl.auto
                    create:程序运行时创建数据库表(如果有表,先删除表再创建)
                    update:程序运行时创建表(如果有表,不会创建表)
                    none:不回创建表
            --&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot;/&gt;
        &lt;/properties&gt;

    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre><h3 id="编写客户的实体类"><a href="#编写客户的实体类" class="headerlink" title="编写客户的实体类"></a>编写客户的实体类</h3><h3 id="配置实体类和表-类中属性和表中字段的映射关系"><a href="#配置实体类和表-类中属性和表中字段的映射关系" class="headerlink" title="配置实体类和表,类中属性和表中字段的映射关系"></a>配置实体类和表,类中属性和表中字段的映射关系</h3><pre><code>package com.kobe.domain;

import javax.persistence.*;

/**
 * 客户的实体类
 *  配置映射关系
 *      1.实体类和表的映射关系
 *          @Entity:声明实体类
 *          @Table:配置实体类和表的映射关系
 *              name:配置数据库表的名称
 *
 *      2.实体类中属性和表中字段的映射关系
 *
 *
 *
 */
@Entity
@Table(name = &quot;cst_customer&quot;)
public class Customer {
    /**
     * @Id:声明主键的配置
     * @GeneratedValue:配置主键的生成策略
     *      strategy
     *      GenerationType.IDENTITY:自增--mysql
     *          底层数据库必须支持自动增长(底层数据库支持的自动增长的方式,对id自增)
     *      GenerationType.SEQUENCE:序列--Oracle
     *          底层数据库必须支持序列
     *      GenerationType.TABLE:jpa提供的一种机制,通过一张数据库表的形式完成主键自增
     *      GenerationType.AUTO:由程序自动的帮助我们选择主键生成策略
     * @Column:配置属性和字段的映射关系
     *      name:数据库表中字段的名称
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;cust_id&quot;)
    private Long custId;//客户主键

    @Column(name = &quot;cust_name&quot;)
    private String custName;//客户名称

    @Column(name = &quot;cust_source&quot;)
    private String custSource;//客户来源

    @Column(name = &quot;cust_level&quot;)
    private String custLevel;//客户级别

    @Column(name = &quot;cust_industry&quot;)
    private String custIndustry;//可不所属行业

    @Column(name = &quot;cust_phone&quot;)
    private String custPhone;//客户的联系方式

    @Column(name = &quot;cust_address&quot;)
    private String custAddress;//客户地址

    public Long getCustId() {
        return custId;
    }

    public void setCustId(Long custId) {
        this.custId = custId;
    }

    public String getCustName() {
        return custName;
    }

    public void setCustName(String custName) {
        this.custName = custName;
    }

    public String getCustSource() {
        return custSource;
    }

    public void setCustSource(String custSource) {
        this.custSource = custSource;
    }

    public String getCustLevel() {
        return custLevel;
    }

    public void setCustLevel(String custLevel) {
        this.custLevel = custLevel;
    }

    public String getCustIndustry() {
        return custIndustry;
    }

    public void setCustIndustry(String custIndustry) {
        this.custIndustry = custIndustry;
    }

    public String getCustPhone() {
        return custPhone;
    }

    public void setCustPhone(String custPhone) {
        this.custPhone = custPhone;
    }

    public String getCustAddress() {
        return custAddress;
    }

    public void setCustAddress(String custAddress) {
        this.custAddress = custAddress;
    }

    @Override
    public String toString() {
        return &quot;Customer{&quot; +
                &quot;custId=&quot; + custId +
                &quot;, custName=&apos;&quot; + custName + &apos;\&apos;&apos; +
                &quot;, custSource=&apos;&quot; + custSource + &apos;\&apos;&apos; +
                &quot;, custLevel=&apos;&quot; + custLevel + &apos;\&apos;&apos; +
                &quot;, custIndustry=&apos;&quot; + custIndustry + &apos;\&apos;&apos; +
                &quot;, custPhone=&apos;&quot; + custPhone + &apos;\&apos;&apos; +
                &quot;, custAddress=&apos;&quot; + custAddress + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}</code></pre><h3 id="保存客户到数据库中"><a href="#保存客户到数据库中" class="headerlink" title="保存客户到数据库中"></a>保存客户到数据库中</h3><pre><code>/**
 * 测试jpa的保存
 *  保存一个客户到数据库中
 *
 *  Jpa的操作步骤
 *      1.加载配置文件创建工厂(实体管理器工厂)对象
 *      2.通过实体管理器工厂获取实体管理器
 *      3.通过实体管理器获取事务对象,开启事务
 *      4.完成增删改查操作
 *      5.提交事务(回滚事务)
 *      6.释放资源
 */
@Test
public void testSave() throws Exception{
    //1.加载配置文件创建工厂(实体管理器工厂)对象
    EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
    //2.通过实体管理器工厂获取实体管理器
    EntityManager em = factory.createEntityManager();
    //3.通过实体管理器获取事务对象,开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //4.完成增删改查操作(保存一个客户到数据库)
    Customer customer = new Customer();
    customer.setCustName(&quot;bryant&quot;);
    customer.setCustIndustry(&quot;basketball&quot;);
    //保存
    em.persist(customer);//666
    //5.提交事务(回滚事务)
    tx.commit();
    //6.释放资源
    em.close();
    factory.close();

}</code></pre><h2 id="总结-jpa操作的基本步骤"><a href="#总结-jpa操作的基本步骤" class="headerlink" title="总结:jpa操作的基本步骤:"></a>总结:jpa操作的基本步骤:</h2><h3 id="1-加载配置文件创建实体管理器工厂"><a href="#1-加载配置文件创建实体管理器工厂" class="headerlink" title="1.加载配置文件创建实体管理器工厂"></a>1.加载配置文件创建实体管理器工厂</h3><pre><code>Persistence:静态方法(根据持久化单元名称创建实体管理器工厂)
方法:createEntityManagerFactory(持久化单元名称)
作用:创建实体管理器工厂</code></pre><h3 id="2-根据实体管理器工厂-创建实体管理器"><a href="#2-根据实体管理器工厂-创建实体管理器" class="headerlink" title="2.根据实体管理器工厂,创建实体管理器"></a>2.根据实体管理器工厂,创建实体管理器</h3><pre><code>EntityManagerFactory:获取 EntityManager对象
方法:createEntityManager
*内部维护了很多内容
    内部维护了数据库信息
    维护了缓存信息
    维护了所有的实体管理器对象
    在创建EntityManagerFactory的过程中会根据配置创建数据库表
*EntityManagerFactory的创建过程比较浪费资源
特点:线程安全的对象
    多个线程访问同一个EntityManagerFactory不会有线程安全问题
*如何解决EntityManagerFactory的创建过程浪费资源的问题
    思路:创建一个公共的EntityManagerFactory对象
    *静态代码块的形式创建EntityManagerFactory</code></pre><hr>
<p>静态代码块思想,抽取JpaUtils工具类:</p>
<pre><code>/**
 * 解决实体管理器工厂的浪费资源和耗时问题
 *      通过静态代码块的形式,当程序第一次访问此工具类时,创建一个公共的实体管理器对象
 *
 *      第一次访问getEntityManager方法:经过静态代码块创建factory对象,再调用方法传一个EntityManager对象
 *      第二次访问getEntityManager方法:直接通过一个已经创建好的factory对象,创建EntityManager对象
 *
 */
public class JpaUtils {

    private static EntityManagerFactory factory;

    static {
        //1.加载配置文件,创建EntityManagerFactory
        factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
    }

    /**
     * 获取EntityManager对象
     */
    public static EntityManager getEntityManager() {
        return factory.createEntityManager();
    }    
}</code></pre><h3 id="3-根据实体管理器创建事务对象-开启事务"><a href="#3-根据实体管理器创建事务对象-开启事务" class="headerlink" title="3.根据实体管理器创建事务对象,开启事务"></a>3.根据实体管理器创建事务对象,开启事务</h3><h3 id="4-增删改查操作"><a href="#4-增删改查操作" class="headerlink" title="4.增删改查操作"></a>4.增删改查操作</h3><h3 id="5-提交事务"><a href="#5-提交事务" class="headerlink" title="5. 提交事务"></a>5. 提交事务</h3><pre><code>EntityManager对象:实体类管理器
方法:beginTransaction:创建事务对象
    presist:保存
    merge:更新
    remove:删除
    find(立即加载)/getReference(延迟加载/懒加载) :根据id查询

Transaction对象:事务
方法:begin:开启事务
    commit:提交事务
    rollback:回滚</code></pre><h3 id="6-释放资源"><a href="#6-释放资源" class="headerlink" title="6. 释放资源"></a>6. 释放资源</h3><h4 id="根据id进行查询"><a href="#根据id进行查询" class="headerlink" title="根据id进行查询"></a>根据id进行查询</h4><pre><code>/**
 * 根据id查询客户
 * 使用find方法查询
 *      1.查询的对象就是当前客户对象本身
 *      2.在调用find方法的时候,就会发送sql语句查询数据库
 */
@Test
public void testFind() {
    //1.通过工具类获取EntityManager
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.增删改查操作
    /**
     * find:根据id查询客户
     *      class:查询数据的结果需要包装的实体类的字节码
     *      id:查询的主键的取值
     *
     * 立即加载
     */
    Customer customer = em.find(Customer.class, 1l);
    System.out.println(customer);
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}

/**
 * 根据id查询客户
 *  使用getReference方法查询
 *      1.查询的对象是一个动态代理对象
 *      2.在调用getReference方法不会立即发送sql语句查询数据库
 *          当调用查询结果对象的时候,才会发送查询的sql语句(什么时候用,什么时候发)
 *
 *  延迟加载/懒加载
 */
@Test
public void testReference() {
    //1.通过工具类获取EntityManager
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.增删改查操作
    /**
     * find:根据id查询客户
     *      class:查询数据的结果需要包装的实体类的字节码
     *      id:查询的主键的取值
     */
    Customer customer = em.getReference(Customer.class, 1l);
    System.out.println(customer);
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h4 id="删除客户"><a href="#删除客户" class="headerlink" title="删除客户"></a>删除客户</h4><pre><code>/**
 * 删除客户
 */
@Test
public void testRemove() {
    //1.通过工具类获取EntityManager
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.增删改查操作
    //3.1根据id查询客户
    Customer customer = em.getReference(Customer.class, 1l);
    //3.2调用remove方法
    em.remove(customer);
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h4 id="客户的更新"><a href="#客户的更新" class="headerlink" title="客户的更新"></a>客户的更新</h4><pre><code>/**
 * 更新客户的操作
 */
@Test
public void testUpdate() {
    //1.通过工具类获取EntityManager
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.增删改查操作
    //3.1根据id查询客户
    Customer customer = em.getReference(Customer.class, 1l);
    //3.2更新客户
    customer.setCustIndustry(&quot;basketball&quot;);
    em.merge(customer);
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h1 id="五-JPQL查询"><a href="#五-JPQL查询" class="headerlink" title="五.JPQL查询"></a>五.JPQL查询</h1><h3 id="JPQL全称Java-Persistence-Query-Language"><a href="#JPQL全称Java-Persistence-Query-Language" class="headerlink" title="JPQL全称Java Persistence Query Language"></a>JPQL全称Java Persistence Query Language</h3><pre><code>sql:查询的是表和表中的字段
jpql:查询的是实体类和类中的属性
*jpql和sql语句的语法相似</code></pre><h2 id="1-查询全部"><a href="#1-查询全部" class="headerlink" title="1.查询全部"></a>1.查询全部</h2><pre><code>/**
 * 查询全部
 * jpql:from com.kobe.domain.Customer
 * sql: select * from cst_customer
 */
@Test
public void testFindAll() {
    //1.获取entityManager对象
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.查询全部
    String jpql = &quot;from com.kobe.domain.Customer&quot;;
    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jpql的对象
    //发送查询并封装结果集
    List list = query.getResultList();

    for (Object o : list) {
        System.out.println(o);
    }
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h2 id="2-分页查询"><a href="#2-分页查询" class="headerlink" title="2.分页查询"></a>2.分页查询</h2><pre><code>/**
 * 分页查询
 *      sql: SELECT * FROM cst_customer LIMIT 0,1
 *      jpql:from Customer
 */
@Test
public void testPaged() {
    //1.获取entityManager对象
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.查询全部
    //3.1根据jpql语句创建Query查询对象
    String jpql = &quot;from Customer&quot;;
    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jpql的对象
    //3.2对参数赋值--分页参数
    //起始索引
    query.setFirstResult(0);
    //每页条数
    query.setMaxResults(2);
    //发送查询并封装结果集
    /**
     * getResultList:直接将查询结果封装为list集合
     * getSingleResult:得到唯一的结果
     */
    List list = query.getResultList();
    for (Object o : list) {
        System.out.println(o);
    }
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h2 id="3-统计查询"><a href="#3-统计查询" class="headerlink" title="3.统计查询"></a>3.统计查询</h2><pre><code>/**
 * 使用jpql查询,统计客户总数
 *      sql: select count(cust_id) from cst_customer
 *      jpql:select count(custId) from Customer
 */
@Test
public void testCount() {
    //1.获取entityManager对象
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.查询全部
    String jpql = &quot;select count(custId) from Customer&quot;;
    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jpql的对象
    //发送查询并封装结果集
    /**
     * getResultList:直接将查询结果封装为list集合
     * getSingleResult:得到唯一的结果
     */
    Object result = query.getSingleResult();

    System.out.println(result);
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h2 id="4-条件查询"><a href="#4-条件查询" class="headerlink" title="4.条件查询"></a>4.条件查询</h2><pre><code>/**
 * 条件查询 查询客户名称已&apos;k&apos;开头的客户
 *      sql: SELECT * FROM cst_customer WHERE cust_name LIKE &apos;k%&apos;
 *      jpql:from Customer where custName like ?
 */
@Test
public void testCondition() {
    //1.获取entityManager对象
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.查询全部
    //3.1根据jpql语句创建Query查询对象
    String jpql = &quot;from Customer where custName like ?&quot;;
    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jpql的对象
    //3.2对参数赋值--占位符参数
    //第一个参数:占位符索引位置  第二个参数:取值
    query.setParameter(1,&quot;k%&quot;);
    //发送查询并封装结果集
    /**
     * getResultList:直接将查询结果封装为list集合
     * getSingleResult:得到唯一的结果
     */
    List list = query.getResultList();
    for (Object o : list) {
        System.out.println(o);
    }
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5.排序"></a>5.排序</h2><pre><code>/**
 * 根据id倒序查询全部客户
 *      sql: select * from cst_customer order by cust_id desc
 *      jpql:from Customer order by custId desc
 */
@Test
public void testOrders() {
    //1.获取entityManager对象
    EntityManager em = JpaUtils.getEntityManager();
    //2.开启事务
    EntityTransaction tx = em.getTransaction();
    tx.begin();
    //3.倒序查询全部
    String jpql = &quot;from Customer order by custId desc&quot;;
    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jpql的对象
    //发送查询并封装结果集
    List list = query.getResultList();

    for (Object o : list) {
        System.out.println(o);
    }
    //4.提交事务
    tx.commit();
    //5.释放资源
    em.close();
}</code></pre><h1 id="六-Spring-Data-JPA"><a href="#六-Spring-Data-JPA" class="headerlink" title="六.Spring Data JPA"></a>六.Spring Data JPA</h1><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率</p>
<p><strong>Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦</strong></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>案例:客户的基本CRUD</p>
<h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><p>创建工程导入坐标</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.kobe&lt;/groupId&gt;
    &lt;artifactId&gt;jpa_day02&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
        &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt;
        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
        &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;
        &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- junit单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.9&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- spring beg --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.6.8&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- spring end --&gt;

        &lt;!-- hibernate beg --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;${hibernate.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
            &lt;version&gt;${hibernate.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
            &lt;version&gt;5.2.1.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- hibernate end --&gt;

        &lt;!-- c3p0 beg --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;c3p0&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;${c3p0.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- c3p0 end --&gt;

        &lt;!-- log end --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;${log4j.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- log end --&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;${mysql.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--spring-data-jpa的坐标--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
            &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- el beg 使用spring data jpa 必须引入 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.el&lt;/groupId&gt;
            &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;
            &lt;version&gt;2.2.4&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;
            &lt;artifactId&gt;javax.el&lt;/artifactId&gt;
            &lt;version&gt;2.2.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- el end --&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;    </code></pre><p>配置spring的配置文件(整合spring data jpa)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/data/jpa
        http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;&gt;

    &lt;!--spring和spring data jpa的配置--&gt;

    &lt;!--1.创建entityManagerFactory对象交给spring容器管理--&gt;
    &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--配置的是扫描的包(实体类所在的包)--&gt;
        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.kobe.domain&quot;/&gt;
        &lt;!--jpa的实现方式--&gt;
        &lt;property name=&quot;persistenceProvider&quot;&gt;
            &lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;/&gt;
        &lt;/property&gt;

        &lt;!--jpa的供应商适配器--&gt;
        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;
            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;
                &lt;!--配置是否自动创建数据库表--&gt;
                &lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;
                &lt;!--指定数据库类型--&gt;
                &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;
                &lt;!--数据库方言:支持的特有语法--&gt;
                &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;
                &lt;!--是否显示sql--&gt;
                &lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt;
            &lt;/bean&gt;
        &lt;/property&gt;

        &lt;!--jpa的方言:高级特性--&gt;
        &lt;property name=&quot;jpaDialect&quot;&gt;
            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;/&gt;
        &lt;/property&gt;

    &lt;/bean&gt;

    &lt;!--2.创建数据库连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///jpa&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--3.整合spring dataJpa--&gt;
    &lt;jpa:repositories base-package=&quot;com.kobe.dao&quot; transaction-manager-ref=&quot;transactionManager&quot;
     entity-manager-factory-ref=&quot;entityManagerFactory&quot;&gt;&lt;/jpa:repositories&gt;

    &lt;!--4.配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;
        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--5.声明式事务--&gt;

    &lt;!--6.配置包扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.kobe&quot;/&gt;

&lt;/beans&gt;</code></pre><p>编写实体类(客户实体类,使用jpa注解配置映射关系)<br>同上</p>
<h3 id="2-编写一个符合spring-Data-Jpa的dao层接口"><a href="#2-编写一个符合spring-Data-Jpa的dao层接口" class="headerlink" title="2.编写一个符合spring Data Jpa的dao层接口"></a>2.编写一个符合spring Data Jpa的dao层接口</h3><p>dao层接口规范:  </p>
<ol>
<li><p>需要继承两个接口(JpaRepository,JpaSpecificationExecutor)  </p>
</li>
<li><p>需要提供响应的泛型</p>
<p> /**</p>
<ul>
<li>符合SpringDateJpa层接口规范</li>
<li>JpaRepository&lt;操作的实体类类型,实体类中主键属性的类型&gt;</li>
<li>封装了基本CURD操作</li>
<li>JpaSpecificationExecutor&lt;操作的实体类类型&gt;</li>
<li>封装了复杂查询(分页)</li>
<li>/<br>public interface CustomerDao extends JpaRepository&lt;Customer,Long&gt;,JpaSpecificationExecutor<customer> {<br>}</customer></li>
</ul>
</li>
</ol>
<h3 id="3-测试类编写"><a href="#3-测试类编写" class="headerlink" title="3.测试类编写"></a>3.测试类编写</h3><pre><code>//声明spring提供的单元测试环境
@RunWith(SpringJUnit4ClassRunner.class)
//指定spring容器的配置信息
@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)
public class CustomerDaoTest {
    @Autowired
    private CustomerDao customerDao;

    /**
     * 根据id查询
     */
    @Test
    public void testFindOne() {
        Customer customer = customerDao.findOne(4l);
        System.out.println(customer);
    }

    /**
     * save:保存或者更新
     *      根据传递的对象是否存在主键id:
     *          如果没有id主键属性:保存
     *          如果存在id逐渐属性:根据id查询数据,更新数据
     */
    @Test
    public void testSave() {
        Customer customer = new Customer();
        customer.setCustName(&quot;乔碧罗&quot;);
        customer.setCustLevel(&quot;level6&quot;);
        customer.setCustIndustry(&quot;军事&quot;);
        customerDao.save(customer);
    }

    @Test
    public void testUpdate() {
        Customer customer = new Customer();
        customer.setCustName(&quot;JOJO&quot;);
        customer.setCustId(5l);
        customer.setCustLevel(&quot;level8&quot;);
        customer.setCustIndustry(&quot;替身&quot;);
        customerDao.save(customer);
    }

    @Test
    public void testDelete(){
        customerDao.delete(6l);
    }

    @Test
    public void testFindAll(){
        List&lt;Customer&gt; list = customerDao.findAll();
        for (Customer customer : list) {
            System.out.println(customer);
        }
    }
}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><pre><code>findOne(id):根据id查询
save(customer):保存或者更新(依据:传递的实体类对象中,是否包含id属性)
delete(id):根据id删除
findAll():查询全部</code></pre><h2 id="Spring-Data-JPA的内部原理剖析"><a href="#Spring-Data-JPA的内部原理剖析" class="headerlink" title="Spring Data JPA的内部原理剖析"></a>Spring Data JPA的内部原理剖析</h2><pre><code>1.通过JdkDynamicAopProxy的invoke方法创建了一个动态代理对象
2.SimpleJpaRepository当中封装了JPA的操作（借助JPA的api完成数据库的CRUD）
3.通过hibernate完成数据库操作（封装了jdbc）</code></pre><p><img src="https://i.loli.net/2019/10/12/2TBLtEy38fdwpGj.png" alt="2.png"></p>
<h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><h3 id="1-借助接口中定义好的方法完成查询"><a href="#1-借助接口中定义好的方法完成查询" class="headerlink" title="1.借助接口中定义好的方法完成查询"></a>1.借助接口中定义好的方法完成查询</h3><p><strong>继承JpaRepository后的方法列表</strong><br><img src="https://i.loli.net/2019/10/12/axjW6IwtS8OCniG.png" alt="3.png"></p>
<pre><code>/**
 * 测试统计查询:查询客户总数量
 *      count:统计总条数
 */
@Test
public void testCount() {
    long count = customerDao.count();
    System.out.println(count);
}

/**
 * 判断id为4的客户是否存在
 */
@Test
public void testExists() {
    boolean b = customerDao.exists(6l);
    System.out.println(b);
}

/**
 * 根据id查询
 *  保证getOne正常运行
 *
 *  findOne:
 *      em.find()  立即加载
 *  getOne:
 *      em.getReference()  延迟加载
 *          返回的是一个客户的动态代理对象
 *          随用随查询
 */
@Test
@Transactional
public void testGetOne() {
    Customer customer = customerDao.getOne(4l);
    System.out.println(customer);
}</code></pre><p><strong>继承JpaSpecificationExecutor的方法列表</strong><br><img src="https://i.loli.net/2019/10/12/CKGkEcqW4xJydi1.png" alt="4.png"></p>
<h3 id="2-jpql的查询方式"><a href="#2-jpql的查询方式" class="headerlink" title="2.jpql的查询方式"></a>2.jpql的查询方式</h3><p>jpql:Jpa query language(jpa查询语言)<br>特点:语法或关键字和sql语句类似,查询的是类和类中属性</p>
<p>需要将JPQL语句配置到接口方法上<br>1.特有的查询L需要在dao接口上配置方法<br>2.在新添加的方法上，使用注解的形式配置jpql查询语句<br>3.注解 ： @Query</p>
<pre><code>/**
 * 案例:根据客户名称查询客户
 *      使用jpql形式查询
 *  jpql:from Customer where custName = ?
 *
 *  配置jpql语句,使用@Query注解
 */
@Query(value = &quot;from Customer where custName = ?&quot;)
public Customer findJpql(String custName);

/**
 * 案例:根据客户名称和客户id查询客户
 * jpql:from Customer where custName = ? and custId = ?
 *
 * 对于多个占位符参数
 *      赋值的时候,默认情况下,占位符位置需要和方法参数中的位置保持一致
 *
 * 可以知道占位符参数的位置
 *  ? 索引的方式,指定此占位的取值来源
 *  如:from Customer where custName = ?2 and custId = ?1
 */
@Query(value = &quot;from Customer where custName = ? and custId = ?&quot;)
public Customer findCustNameAndId(String name,Long id);

/**
 * 更新
 * 案例:根据id,更新客户的名称
 *      更新4号客户的名称,将名称改为&quot;DIO&quot;
 *
 * sql: update cst_customer set cust_name = ? where cust_id = ?
 * jpql:update Customer set custName = ? where custId = ?
 *
 * @Query:代表的是进行查询
 *      声明此方法是用来更新操作的
 * @Modifying
 *      表示当前执行的是一个更新操作
 *
 * Spring Data JPA中使用jpql完成更新/删除操作
 *      需要手动添加事务支持
 *      默认会结束之后回滚事务
 *      需要添加@Rollback(value = false)//设置不回滚
 */
@Query(value = &quot;update Customer set custName = ?2 where custId = ?1&quot;)
@Modifying
public void updateCustomer(Long custId,String custName);</code></pre><h3 id="3-sql语句的查询方式"><a href="#3-sql语句的查询方式" class="headerlink" title="3.sql语句的查询方式"></a>3.sql语句的查询方式</h3><p>1.特有的查询L需要在dao接口上配置方法<br>2.在新添加的方法上，使用注解的形式配置jpql查询语句<br>3.注解 ： @Query</p>
<pre><code>@Query
value:jpql语句|sql语句
nativaQuery:false(使用jpql)|true(使用本地查询--sql查询)
    是否使用本地查询</code></pre><p>代码:</p>
<pre><code>/**
 * 使用sql的形式查询
 *      查询全部的客户
 * sql:select * from cst_customer
 *      value:sql
 *      nativeQuery:true--sql
 */
@Query(value = &quot;select * from cst_customer&quot;,nativeQuery = true)
public List&lt;Object []&gt; findSql();

/**
 * 模糊匹配
 * @return
 */
@Query(value = &quot;select * from cst_customer where cust_name like ?1&quot;,nativeQuery = true)
public List&lt;Object []&gt; findSql2(String name);</code></pre><h3 id="4-方法名称规则查询"><a href="#4-方法名称规则查询" class="headerlink" title="4.方法名称规则查询"></a>4.方法名称规则查询</h3><p>是对jpql查询更加深入的一层封装,我们只需要按照spring data jpa提供的方法名称规则定义方法,不需要再去配置jpql语句,完成查询</p>
<pre><code>/**
 * 方法名的约定:
 *      findBy:查询
 *          对象中的属性名(首字母大写):查询的条件
 * 如:findByCustName---根据客户名称查询
 *
 * 在springdatajpa的运行阶段
 *      会根据方法名称进行解析  findBy  from  xxx(实体类)
 *                              属性名称    where custName = ?
 *
 *  1.findBy + 属性名称(根据属性名称进行完全匹配的查询=)
 *  2.findBy + 属性名称 + &quot;查询方式(like|isnull)&quot;
 *      findByCustNameLike
 *  3.多条件查询
 *      findBy + 属性名 + &quot;查询方式&quot; + &quot;多条件的连接符(and|or)&quot; + 属性名 + &quot;查询方式&quot;
 */
//使用客户名称精准匹配
public Customer findByCustName(String custName);

//使用客户名称模糊匹配
public List&lt;Customer&gt; findByCustNameLike(String custName);

//使用客户名称模糊匹配和客户所属行业精准匹配
public Customer findByCustNameLikeAndCustIndustry(String custName,String custIndustry);</code></pre><h1 id="七-Specifications动态查询"><a href="#七-Specifications动态查询" class="headerlink" title="七.Specifications动态查询"></a>七.Specifications动态查询</h1><p>JpaSpecificationExecutor 方法列表</p>
<pre><code>T findOne(Specification&lt;T&gt; spec);  //查询单个对象

List&lt;T&gt; findAll(Specification&lt;T&gt; spec);  //查询列表

//查询全部，分页
//pageable：分页参数
//返回值：分页pageBean（page：是springdatajpa提供的）
Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);

//查询列表
//Sort：排序参数
List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort);

long count(Specification&lt;T&gt; spec);//统计查询</code></pre><p>Specification ：查询条件</p>
<pre><code>自定义我们自己的Specification实现类
    实现
        //root：查询的根对象（查询的任何属性都可以从根对象中获取）
        //CriteriaQuery：顶层查询对象，自定义查询方式（了解：一般不用）
        //CriteriaBuilder：查询的构造器，封装了很多的查询条件
        Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb); //封装查询条件</code></pre><h3 id="查询单个对象"><a href="#查询单个对象" class="headerlink" title="查询单个对象"></a>查询单个对象</h3><pre><code>/**
 * 根据条件查询单个对象
 */
@Test
public void testSpec() {
    //匿名内部类
    /**
     * 自定义查询条件
     *      1.实现Specification接口(提供泛型,查询的对象类型)
     *      2.实现toPredicate方法(构造查询条件)
     *      3.需要借助方法参数中的两个参数(
     *          root:获取需要查询的对象属性
     *          CriteriaBuilder:构造查询条件的,内部封装了很多的查询条件(模糊匹配,精确匹配)
     *      )
     *
     *      案例:根据客户名称查询,查询客户名为kobe的客户
     *              查询条件:
     *                  1.查询方式
     *                      CriteriaBuilder对象
     *                  2.比较的属性名称
     *                      root对象
     */
    Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() {
        @Override
        public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) {
            //1.获取比较的属性
            Path&lt;Object&gt; custName = root.get(&quot;custName&quot;);
            //2.构造查询
            /**
             * 第一个参数:需要比较的属性(path对象)
             * 第二个参数:当前需要比较的取值
             */
            Predicate kobe = cb.equal(custName, &quot;kobe&quot;);//精准匹配(比较的属性,比较的属性的取值)

            return kobe;
        }
    };
    Customer customer = customerDao.findOne(spec);
    System.out.println(customer);
}</code></pre><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><pre><code>/**
 * 多条件查询
 *      案例:根据客户名(kokodayo)和客户所属行业查询(射箭)
 */
@Test
public void testSpec2() {
    Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() {
        /**
         *
         * @param root 获取属性
         * @param criteriaQuery
         * @param criteriaBuilder 构造查询
         *                     1.构造客户名的精准匹配查询
         *                     2.构造所属行业的精准匹配查询
         *                     3.联系两个查询
         * @return
         */
        @Override
        public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
            Path&lt;Object&gt; custName = root.get(&quot;custName&quot;);
            Path&lt;Object&gt; custIndustry = root.get(&quot;custIndustry&quot;);

            //1.构造客户名的精准匹配查询
            Predicate predicate1 = criteriaBuilder.equal(custName, &quot;kokodayo&quot;);
            //2.构造所属行业的精准匹配查询
            Predicate predicate2 = criteriaBuilder.equal(custIndustry, &quot;射箭&quot;);
            //3.联系两个查询(满足条件1且满足条件2)
            Predicate predicate = criteriaBuilder.and(predicate1, predicate2);

            return predicate;
        }
    };
    Customer customer = customerDao.findOne(spec);
    System.out.println(customer);
}</code></pre><h3 id="模糊匹配查询列表"><a href="#模糊匹配查询列表" class="headerlink" title="模糊匹配查询列表"></a>模糊匹配查询列表</h3><pre><code>/**
 * 案例:根据客户名称模糊匹配,返回客户列表
 *
 * equal:直接得到path对象(属性),然后进行比较即可
 * gt,lt,ge,le,like:得到path对象,根据path对象指定比较的参数类型,再比较
 *      指定参数类型:path.as(类型的字节码对象)
 */
@Test
public void testSpec3() {
    //构造查询条件
    Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() {
        @Override
        public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {
            Path&lt;Object&gt; custName = root.get(&quot;custName&quot;);
            Predicate like = criteriaBuilder.like(custName.as(String.class), &quot;k%&quot;);
            return like;
        }
    };
    List&lt;Customer&gt; list = customerDao.findAll(spec);
    for (Customer customer : list) {
        System.out.println(customer);
    }
}</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code>//添加排序
//创建排序对象 Sort对象
//参数1:排序的顺序  参数2:排序的属性名称
Sort sort = new Sort(Sort.Direction.DESC,&quot;custId&quot;);
List&lt;Customer&gt; list = customerDao.findAll(spec, sort);
for (Customer customer : list) {
    System.out.println(customer);
}</code></pre><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><pre><code>/**
 * 分页查询
 *      findAll(Specification,Pageable) 带有条件的分页
 *          Specification:查询条件
 *          Pageable:查询的页码,每页查询的条数
 *      findAll(Pageable)没有条件的分页
 * 返回:Page(springDataJpa为我们封装好的pageBean对象,数据列表,共条数)
 */
@Test
public void testSpec4() {
    /**
     * PageRequest是pageable接口的实现类
     *
     * 创建PageRequest要调用构造方法传入两个参数
     *      参数1:当前查询的页数(从0开始)
     *      参数2:每页查询的数量
     *
     */
    Pageable pageable = new PageRequest(0,2);
    Page&lt;Customer&gt; page = customerDao.findAll(pageable);
    System.out.println(page.getContent());//得到数据集合列表
    System.out.println(page.getTotalPages());//得到总页数
    System.out.println(page.getTotalElements());//得到总条数
}</code></pre><h1 id="八-多表之间的关系和操作多表的步骤"><a href="#八-多表之间的关系和操作多表的步骤" class="headerlink" title="八.多表之间的关系和操作多表的步骤"></a>八.多表之间的关系和操作多表的步骤</h1><h3 id="表关系"><a href="#表关系" class="headerlink" title="表关系:"></a>表关系:</h3><pre><code>一对一  
一对多:
    一的一方:主表
    多的一方:从表
    外键:需要在从表新建一列作为外键,他的取值来源于主表的主键
多对多:
    中间表:中间表最少应该由两个字段组成,这两个字段作为外键指向两张表的主键,同时这两个字段又组成了联合主键</code></pre><h3 id="实体类中的关系"><a href="#实体类中的关系" class="headerlink" title="实体类中的关系:"></a>实体类中的关系:</h3><pre><code>包含关系:可以通过实体类中的包含关系描述表关系
继承关系

分析步骤
    1.明确表关系
    2.确定表关系（描述 外键|中间表）
    3.编写实体类，再实体类中描述表关系（包含关系）
    4.配置映射关系</code></pre><h1 id="九-多表操作"><a href="#九-多表操作" class="headerlink" title="九.多表操作"></a>九.多表操作</h1><h2 id="1-一对多操作"><a href="#1-一对多操作" class="headerlink" title="1.一对多操作"></a>1.一对多操作</h2><pre><code>案例:客户和联系人的案例(一对多)
    客户:一家公司
    联系人:这家公司的员工

一个客户可以具有多个联系人
一个联系人从属于一家公司


分析步骤
    1.明确表关系
        一对多
    2.确定表关系（描述 外键|中间表）
        主表:客户表
        从表:联系人表
            在从表上添加外键(主表的主键)
    3.编写实体类，再实体类中描述表关系（包含关系）
        客户:在客户的实体类中包含一个联系人的集合
        联系人:在联系人的实体类中包含一个客户的对象
    4.配置映射关系
        使用jpa注解配置一对多映射关系</code></pre><p><strong>在客户中配置联系人(一对多):</strong></p>
<pre><code>//配置客户和联系人之间的关系(一对多)
/**
 * 使用注解配置多表关系
 *      1.声明关系
 *          @OneToMany:配置一对多关系
 *              targetEntity:对方对象的字节码对象
 *      2.配置外键(中间表)
 *          @JoinColumn:配置外键
 *              name:外键字段名称
 *              referencedColumnName:参照的主表主键的名称
 *
 * 在客户实体类上(一)添加了外键配置,所以对于客户而言,客户具有了维护外键的作用
 */
@OneToMany(targetEntity = LinkMan.class)
@JoinColumn(name = &quot;lkm_cust_id&quot;,referencedColumnName = &quot;cust_id&quot;)
private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;&gt;();</code></pre><p><strong>在联系人中配置客户(一对多):</strong></p>
<pre><code>/**
 * 配置联系人到客户的多对一关系
 *      使用注解的形式配置多对一关系
 *      1.配置表关系
 *          @ManyToOne:配置多对一关系
 *              targetEntity:对方的实体类字节码
 *      2.配置外键(中间表)
 *          @JoinColumn:配置外键
 *              name:外键字段名称
 *              referencedColumnName:参照的主表主键的名称
 *
 * 配置外键的过程:配置到了多的一方,就会在多的一方维护外键
 *
 */
@ManyToOne(targetEntity = Customer.class)
@JoinColumn(name = &quot;lkm_cust_id&quot;,referencedColumnName = &quot;cust_id&quot;)
private Customer customer;</code></pre><p><strong>测试的时候,要注意创建实体类之间的关系:</strong></p>
<pre><code>/**
 * 保存一个客户,保存一个联系人
 * 效果:客户和联系人作为独立的数据保存到数据库中
 *      联系人外键为空
 * 原因:
 *      实体类中没有配置关系
 *
 */
@Test
@Transactional//配置事务
@Rollback(value = false)
public void testAdd() {
    //创建一个客户,创建一个联系人
    Customer customer = new Customer();
    customer.setCustName(&quot;Lakers&quot;);

    LinkMan linkMan = new LinkMan();
    linkMan.setLkmName(&quot;kobe&quot;);

    //配置关系
    customer.getLinkMans().add(linkMan);

    //保存
    customerDao.save(customer);
    linkManDao.save(linkMan);
}</code></pre><p><strong>注意:以下例子(一)和(多)都对外键进行了操作</strong></p>
<pre><code>/**
 *会有一条多余的update语句出来
 *      由于一的一方可以维护外键,会发送update语句
 *      解决方案:一的一方放弃维护权
 */
@Test
@Transactional//配置事务
@Rollback(value = false)
public void testAdd3() {
    //创建一个客户,创建一个联系人
    Customer customer = new Customer();
    customer.setCustName(&quot;Lakers&quot;);

    LinkMan linkMan = new LinkMan();
    linkMan.setLkmName(&quot;kobe&quot;);


    linkMan.setCustomer(customer);//由于配置了多到一的关联关系(当保存的时候就已经对外键赋值)
    customer.getLinkMans().add(linkMan);//由于配置了一到多的关联关系(发送一条update语句)

    //保存
    customerDao.save(customer);
    linkManDao.save(linkMan);
}</code></pre><p><strong>解决方案:去客户类(一)中修改以下配置,放弃维护权</strong></p>
<pre><code>/**
 * 放弃外键维护权
 *      mappedBy:对方配置关系的属性名称
  */
@OneToMany(mappedBy = &quot;customer&quot;)
private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;&gt;();</code></pre><p>此时多余的update语句已消失.<br><img src="https://i.loli.net/2019/10/12/RwOY72jZqJhF4Ld.png" alt="5.png"></p>
<h3 id="删除操作的说明如下："><a href="#删除操作的说明如下：" class="headerlink" title="删除操作的说明如下："></a>删除操作的说明如下：</h3><p><strong>删除从表数据：可以随时任意删除。</strong></p>
<p>删除主表数据：</p>
<p><strong>有从表数据</strong><br>  1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表                结构上，外键字段有非空约束，默认情况就会报错了。<br>  2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null，        没有关系）因为在删除时，它根本不会去更新从表的外键字段了。<br>  3、如果还想删除，使用级联删除引用</p>
<h3 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h3><p>级联操作：指操作一个对象同时操作它的关联对象  </p>
<pre><code>1.需要区分操作主体
2.需要在操作主体的实体类上,添加级联属性(添加到多表映射关系的注解上)
3.@cascade(配置级联)</code></pre><h2 id="2-多对多操作"><a href="#2-多对多操作" class="headerlink" title="2.多对多操作"></a>2.多对多操作</h2><pre><code>案例:用户和角色(多对多)
    用户:
    角色:

分析步骤
    1.明确表关系
        一对多
    2.确定表关系（描述 外键|中间表）
        中间表
    3.编写实体类，再实体类中描述表关系（包含关系）
        用户:包含角色的集合
        角色:包含用户的集合
    4.配置映射关系</code></pre><p><strong>配置用户到角色的多对多关系:</strong></p>
<pre><code>/**
 *配置用户到角色的多对多关系
 *
 * 配置多对多映射关系:
 *      1.声明表关系的配置
 *          @ManyToMany(targetEntity = Role.class)
 *              targetEntity:代表对方的实体类字节码
 *      2.配置中间表(包含两个外键)
 *          @JoinTable
 *              name:中间表的名称
 *              joinColumns:当前对象在中间表中的外键
 *                  @JoinColumn的数组
 *                      name:中间表的外键名
 *                      referencedColumnName:参照的主表的主键名
 *              inverseJoinColumns:对方对象在中间表的外键
 *                  @JoinColumn的数组
 *                      name:中间表的外键名
 *                      referencedColumnName:参照的主表的主键名
 */
@ManyToMany(targetEntity = Role.class)
@JoinTable(name = &quot;sys_user_role&quot;,
    //joinColumns:当前对象在中间表中的外键
    joinColumns = {@JoinColumn(name = &quot;sys_user_id&quot;,referencedColumnName = &quot;user_id&quot;)},
    //inverseJoinColumns:对方对象在中间表的外键
    inverseJoinColumns = {@JoinColumn(name = &quot;sys_role_id&quot;,referencedColumnName = &quot;role_id&quot;)}
)
private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();</code></pre><p><strong>配置角色到用户的多对多关系:(放弃维护权)</strong></p>
<pre><code>/**
 *配置角色到用户的多对多关系
 */
@ManyToMany(mappedBy = &quot;roles&quot;)
private Set&lt;User&gt; users = new HashSet&lt;&gt;();</code></pre><p><strong>Test:</strong></p>
<pre><code>/**
 * 保存一个用户,保存一个角色
 *
 * 多对多中放弃维护权:被动的一方放弃
 */
@Test
@Transactional
@Rollback(false)
public void testAdd() {
    User user = new User();
    user.setUserName(&quot;kobe&quot;);

    Role role = new Role();
    role.setRoleName(&quot;basketball player&quot;);

    //配置用户到角色的关系,可以对中间表中的数据进行维护
    user.getRoles().add(role);
    //配置角色到用户的关系
    role.getUsers().add(user);

    userDao.save(user);
    roleDao.save(role);

}

//级联
/**
 * 级联添加(保存一个用户的同时保存用户的管理角色)
 */
@Test
@Transactional
@Rollback(false)
public void testCascadeAdd() {
    User user = new User();
    user.setUserName(&quot;kobe&quot;);

    Role role = new Role();
    role.setRoleName(&quot;basketball player&quot;);

    //配置用户到角色的关系,可以对中间表中的数据进行维护
    user.getRoles().add(role);

    userDao.save(user);
}

/**
 * 级联删除:删除id为1的用户,同时删除他的关联角色
 */
@Test
@Transactional
@Rollback(false)
public void testCascadeDelete() {
    userDao.delete(1l);
}</code></pre><h2 id="3-多表的查询"><a href="#3-多表的查询" class="headerlink" title="3.多表的查询"></a>3.多表的查询</h2><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p><strong>从一查多:</strong></p>
<pre><code>查询一个对象的同时,通过此对象查询他的关联对象

案例:客户与联系人

//could not initialize proxy - no Session
//测试对象导航查询(get方式)
/**
 * 对象导航查询:
 * 默认使用的是延迟加载形式查询:
 *      调用get方法并不会立即发送查询,而是在使用关联对象的时候才会查询
 *
 * 如要使用立即加载:
 *      修改配置fetch,配置到多表映射关系的注解上
 *      fetch:配置关联对象的加载方式
 *          EAGER:立即加载
 *          LAZY:延迟加载
 */
@Test
@Transactional//解决no Session问题
public void testQuery1() {
    //查询id为1的客户
    Customer customer = customerDao.getOne(1l);
    //对象导航查询,此客户下的所有联系人
    Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();
    for (LinkMan linkMan : linkMans) {
        System.out.println(linkMan);
    }
}</code></pre><p><strong>从多查一:</strong></p>
<pre><code>/**
 * 从联系人对象查询客户对象
 *      默认:立即加载
 *  如要使用延迟加载:
 *      在主体(联系人)的多对一种添加fetch配置(LAZY)
 */
@Test
@Transactional//解决no Session问题
public void testQuery3() {
    //获取id为2的联系人
    LinkMan linkMan = linkManDao.findOne(2l);
    //对象导航查询所属客户
    Customer customer = linkMan.getCustomer();
    System.out.println(customer);
}</code></pre><p><strong>总结:</strong></p>
<pre><code>从一查多
    默认:使用延迟加载

从多查一
    默认:使用立即加载</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle学习笔记</title>
    <url>/2019/10/12/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-Oracle体系结构"><a href="#1-Oracle体系结构" class="headerlink" title="1.Oracle体系结构"></a>1.Oracle体系结构</h1><ol>
<li><p>数据库<br>Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。</p>
</li>
<li><p>实例<br>一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。</p>
</li>
<li><p>用户<br>用户是在实例下建立的。不同实例可以建相同名字的用户。(相当于mysql的数据库)</p>
</li>
</ol><a id="more"></a>
<ol start="4">
<li>表空间<br>表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。每个数据库至少有一个表空间(称之为system表空间)。 每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile)。一个数据文件只能属于一个表空间。<br><img src="https://i.loli.net/2019/10/12/zZtdCAkBH92FsmS.png" alt="1.png"></li>
</ol>
<ol start="5">
<li>数据文件（dbf、ora）<br>数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。<br><img src="https://i.loli.net/2019/10/12/nd9pfuKFAZsyNqR.png" alt="2.png"><br><img src="https://i.loli.net/2019/10/12/MX7J3xNrCaVo4jK.png" alt="3.png"></li>
</ol>
<h1 id="2-表空间与用户的创建"><a href="#2-表空间与用户的创建" class="headerlink" title="2.表空间与用户的创建"></a>2.表空间与用户的创建</h1><pre><code>--创建表空间
create tablespace kobe
datafile &apos;d:\kobe.dbf&apos;
size 100m
autoextend on
next 10m;

--删除表空间
drop tablespace kobe;

--创建用户
create user kobe
identified by kobe
default tablespace kobe;

--给用户授权
--oracle数据库中常用角色
connect --连接角色,基本角色
resource --开发者角色
dba --超级管理员角色

--给kobe用户授予dba角色
grant dba to kobe;

--切换到kobe用户下</code></pre><h1 id="3-Oracle数据类型"><a href="#3-Oracle数据类型" class="headerlink" title="3.Oracle数据类型"></a>3.Oracle数据类型</h1><h2 id="Varchar，-varchar2"><a href="#Varchar，-varchar2" class="headerlink" title="Varchar， varchar2"></a>Varchar， varchar2</h2><p>表示一个字符串</p>
<h2 id="NUMBER"><a href="#NUMBER" class="headerlink" title="NUMBER"></a>NUMBER</h2><p>NUMBER(n)表示一个整数，长度是n<br>NUMBER(m,n):表示一个小数，总长度是m，小数是n，整数是m-n</p>
<h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h2><p>表示日期类型</p>
<h2 id="CLOB"><a href="#CLOB" class="headerlink" title="CLOB"></a>CLOB</h2><p>大对象，表示大文本数据类型，可存4G</p>
<h2 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a>BLOB</h2><p>大对象，表示二进制数据，可存4G</p>
<h1 id="4-表的管理"><a href="#4-表的管理" class="headerlink" title="4.表的管理"></a>4.表的管理</h1><h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><p>语法：</p>
<pre><code>Create table 表名（
字段1 数据类型 [default 默认值],
字段2 数据类型 [default 默认值],
...
字段n 数据类型 [default 默认值]
）;</code></pre><p>范例：创建person表 </p>
<pre><code>create table person( 
    pid number(10), 
    name varchar2(10), 
);</code></pre><p>表结构的修改:</p>
<pre><code>--添加一列
alter table person add (gender number(1));

--修改列类型
alter table person modify gender char(1);

--修改列名称
alter table person rename column gender to sex;

--删除一列
alter table person drop column sex;</code></pre><h2 id="表的增删改"><a href="#表的增删改" class="headerlink" title="表的增删改"></a>表的增删改</h2><pre><code>--添加一条记录
insert into person (pid,pname) values (1,&apos;张三&apos;);
commit;

--修改一条记录
update person set pname = &apos;李四&apos; where pid = 1;
commit;

--三种删除
--删除表中全部记录
delete from person;

--删除表结构
drop table person;

--先删除表,再次创建表.效果等于删除表中全部记录
--在数据量大的情况下,尤其在表中带有索引的情况下,该操作效率高
--索引可以提高查询效率,但会影响增删改效率
truncate table person;</code></pre><h1 id="5-序列"><a href="#5-序列" class="headerlink" title="5.序列"></a>5.序列</h1><p> 序列不真的属于任何一张表,但是可以逻辑和表做绑定<br> 序列:默认从1开始,依次递增,主要用来给主键赋值使用<br> dual:续表,只是为了补全语法,没有意义  </p>
<pre><code>create sequence s_person;
select s_person.nextval from dual;
--nextval :取得序列的下一个内容
--currval :取得序列的当前内容 </code></pre><p>在插入数据时需要自增的主键中可以这样使用</p>
<pre><code>--添加一条记录
insert into person (pid,pname) values (s_person.nextval,&apos;张三&apos;);
commit;</code></pre><h1 id="6-Scott用户下的表结构"><a href="#6-Scott用户下的表结构" class="headerlink" title="6.Scott用户下的表结构"></a>6.Scott用户下的表结构</h1><p>用户名:scott<br>密码:tiger</p>
<pre><code>--解锁scott用户(超级管理员权限)
alter user scott account unlock;
--解锁scott用户的密码[此句也可以用来重置密码]
alter user scott identified by tiger;</code></pre><h1 id="7-单行函数"><a href="#7-单行函数" class="headerlink" title="7.单行函数"></a>7.单行函数</h1><p>单行函数:作用于一行,返回一个值<br>多行函数:作用于多行,返回一个值</p>
<h2 id="7-1-字符函数"><a href="#7-1-字符函数" class="headerlink" title="7.1 字符函数"></a>7.1 字符函数</h2><pre><code>select upper(&apos;yes&apos;) from dual; --小写变大写
select lower(&apos;YES&apos;) from dual; --大写变小写</code></pre><h2 id="7-2-数值函数"><a href="#7-2-数值函数" class="headerlink" title="7.2 数值函数"></a>7.2 数值函数</h2><pre><code>select round(26.18,1) from dual; --四舍五入,后面的参数表示保留的小数位数
select trunc(56.16,-1) from dual; --直接截取,不四舍五入
select mod(10,3) from dual; --求余数</code></pre><h2 id="7-3-日期函数"><a href="#7-3-日期函数" class="headerlink" title="7.3 日期函数"></a>7.3 日期函数</h2><pre><code>--查询出emp表中所有员工入职距离现在几天
select sysdate-e.hiredate from emp e;

--算出明天此刻
select sysdate+1 from dual;

--查询出emp表中所有员工入职距离现在几月
select months_between(sysdate,e.hiredate) from emp e;

--查询出emp表中所有员工入职距离现在几年
select months_between(sysdate,e.hiredate)/12 from emp e;

--查询出emp表中所有员工入职距离现在几周
select round((sysdate-e.hiredate)/7) from emp e;</code></pre><h2 id="7-4-转换函数"><a href="#7-4-转换函数" class="headerlink" title="7.4 转换函数"></a>7.4 转换函数</h2><pre><code>--日期转为字符串
select to_char(sysdate,&apos;fm yyyy-mm-dd- hh:mi:ss&apos;) from dual;

--24小时计数法
select to_char(sysdate,&apos;fm yyyy-mm-dd- hh24:mi:ss&apos;) from dual;

--字符串转为日期
select to_date( &apos;2019-9-16- 21:39:54&apos;,&apos;fm yyyy-mm-dd- hh24:mi:ss&apos;) from dual;</code></pre><h2 id="7-5-通用函数"><a href="#7-5-通用函数" class="headerlink" title="7.5 通用函数"></a>7.5 通用函数</h2><pre><code>--算出emp表中所有员工的年薪
--奖金里有null值,null与任意数做运算结果都为null
select e.sal*12+nvl(e.comm,0) from emp e;</code></pre><p>–nvl(值1,值2):如果值1为null,计算用值2代替</p>
<h2 id="7-6-条件表达式"><a href="#7-6-条件表达式" class="headerlink" title="7.6 条件表达式"></a>7.6 条件表达式</h2><h3 id="通用写法-mysql和Oracle通用"><a href="#通用写法-mysql和Oracle通用" class="headerlink" title="通用写法(mysql和Oracle通用)"></a>通用写法(mysql和Oracle通用)</h3><p>–给emp表中员工起中文名</p>
<pre><code>select e.ename, 
       case e.ename
         when &apos;SMITH&apos; then &apos;科比&apos;
           when &apos;ALLEN&apos; then &apos;雷阿伦&apos;
             when &apos;WARD&apos; then &apos;韦德&apos;
               else &apos;无名&apos;
                 end
from emp e;</code></pre><p>–判断emp表中员工工资,如果高于3000显示高收入,高于1500低于3000,显示中等,<br>–其余显示低收入</p>
<pre><code>select e.ename, 
       case 
         when e.sal&gt;3000 then &apos;高收入&apos;
           when e.sal&gt;1500 then &apos;中等收入&apos;
               else &apos;低收入&apos;
                 end
from emp e;</code></pre><h2 id="Oracle专用表达式"><a href="#Oracle专用表达式" class="headerlink" title="Oracle专用表达式"></a>Oracle专用表达式</h2><p>Oracle中除了起别名,都用单引号  </p>
<pre><code>select e.ename, 
       decode(e.ename,
         &apos;SMITH&apos;,&apos;科比&apos;,
           &apos;ALLEN&apos;,&apos;雷阿伦&apos;,
             &apos;WARD&apos;,&apos;韦德&apos;,
               &apos;无名&apos;) 中文名
from emp e;</code></pre><h1 id="8-多行函数-聚合函数"><a href="#8-多行函数-聚合函数" class="headerlink" title="8.多行函数(聚合函数)"></a>8.多行函数(聚合函数)</h1><pre><code>select count(1) from emp;--查询总数量
--count(1)相当于count(主键)
select sum(sal) from emp;--工资总和
select max(sal) from emp;--最高工资
select min(sal) from emp;--最低工资
select avg(sal) from emp;--平均工资</code></pre><h1 id="9-分组查询"><a href="#9-分组查询" class="headerlink" title="9.分组查询"></a>9.分组查询</h1><p>先写</p>
<pre><code>select
from
group</code></pre><p>再补全查询内容</p>
<p><strong>查询出每个部门的平均工资</strong></p>
<pre><code>--分组查询中,出现在group by后面的原始列,才能出现在select后面
--没有出现在group by后面的列,想在select后面,必须加上聚合函数
--聚合函数的特性:把多行记录变成一个值
select e.deptno,avg(e.sal)
from emp e
group by e.deptno;</code></pre><p><strong>查询出平均工资高于2000的部门信息</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e,dept d
group by e.deptno
having avg(e.sal)&gt;2000;
--所有条件都不能使用别名来判断(where执行优于select)</code></pre><p><strong>查询出每个部门工资高于800的员工的平均工资</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e
where e.sal&gt;800
group by e.deptno;
--where是过滤分组前的数据,having是过滤分组后的数据
--表现形式:where必须在group by之前.having在group by之后</code></pre><p><strong>查询出每个部门工资高于800的员工的平均工资</strong><br><strong>再查询出平均工资高于2000的部门</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e
where e.sal&gt;800
group by e.deptno
having avg(e.sal)&gt;2000;</code></pre><h2 id="重点-where是过滤分组前的数据-having是过滤分组后的数据"><a href="#重点-where是过滤分组前的数据-having是过滤分组后的数据" class="headerlink" title="重点:where是过滤分组前的数据,having是过滤分组后的数据"></a>重点:where是过滤分组前的数据,having是过滤分组后的数据</h2><h1 id="10-多表查询中的一些概念"><a href="#10-多表查询中的一些概念" class="headerlink" title="10. 多表查询中的一些概念"></a>10. 多表查询中的一些概念</h1><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><pre><code>select * 
from emp e inner join dept d
on e.deptno=d.deptno;</code></pre><h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><pre><code>select *
from emp e,dept d
where e.deptno=d.deptno;</code></pre><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><pre><code>select * 
from emp e inner join dept d
on e.deptno=d.deptno;</code></pre><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><pre><code>--查询出所有部门,以及部门下的员工信息(外连接)
--右外连接(右表在左侧)
select *
from emp e right join dept d
on e.deptno=d.deptno;

--查询所有员工信息,以及员工所属部门信息
--左外连接(左表在左侧)
select *
from emp e left join dept d
on e.deptno=d.deptno;</code></pre><h2 id="oracle中专用外连接"><a href="#oracle中专用外连接" class="headerlink" title="oracle中专用外连接"></a>oracle中专用外连接</h2><pre><code>--加号在哪边,另一边就显示全数据(个人理解:加号表示可扩展的意思)
select *
from emp e,dept d
where e.deptno(+)=d.deptno;</code></pre><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接其实就是在不同的角度把一张表看成多张表</p>
<p><strong>查询出员工姓名,员工领导姓名(这两个都在同一张表)</strong></p>
<pre><code>select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr=e2.empno;</code></pre><p><strong>查询出员工姓名,员工部门名称,员工领导姓名,员工领导部门名称</strong></p>
<pre><code>select e1.ename,d1.dname,e2.ename,d2.dname
from emp e1,emp e2,dept d1,dept d2
where e1.mgr=e2.empno
and e1.deptno=d1.deptno
and e2.deptno=d2.deptno;</code></pre><p><strong>练习:查询出每个员工编号，姓名，部门名称，工资等级和他的上级领导的姓名，工资等级</strong></p>
<pre><code>select 
e1.empno 员工编号,e1.ename 员工姓名,
d.dname 部门姓名,s1.grade 工资等级,
e2.ename 领导姓名,s2.grade 领导工资等级
from emp e1,emp e2,dept d,salgrade s1,salgrade s2
where e1.mgr=e2.empno
and e1.deptno=d.deptno 
and e1.sal between s1.losal and s1.hisal
and e2.sal between s2.losal and s2.hisal</code></pre><h1 id="11-子查询"><a href="#11-子查询" class="headerlink" title="11.子查询"></a>11.子查询</h1><h2 id="返回一个值"><a href="#返回一个值" class="headerlink" title="返回一个值"></a>返回一个值</h2><pre><code>--查询出工资和scott一样的员工信息
select * from emp e where e.sal =
(select sal from emp where ename=&apos;SCOTT&apos;);</code></pre><h2 id="子查询返回一个集合"><a href="#子查询返回一个集合" class="headerlink" title="子查询返回一个集合"></a>子查询返回一个集合</h2><pre><code>--查询出工资和10号部门任意员工一样的员工信息
select * from emp where sal in
(select sal from emp where deptno=10);</code></pre><h2 id="子查询返回一张表"><a href="#子查询返回一张表" class="headerlink" title="子查询返回一张表"></a>子查询返回一张表</h2><pre><code>--查询出每个部门最低工资,和最低工资员工姓名,和该员工所在部门名称
--(1)先查询出每个部门最低工资
select deptno,min(sal) msal
from emp
group by deptno;

--(2)三表联查
select t.deptno,t.msal,e.ename,d.dname
from (select deptno,min(sal) msal
      from emp
      group by deptno) t,emp e,dept d
where t.deptno=e.deptno
and t.msal=e.sal
and e.deptno=d.deptno;</code></pre><h1 id="12-Oracle中的分页"><a href="#12-Oracle中的分页" class="headerlink" title="12.Oracle中的分页"></a>12.Oracle中的分页</h1><h2 id="rownum行号"><a href="#rownum行号" class="headerlink" title="rownum行号:"></a>rownum行号:</h2><p>当我们做select操作的时候,每查询出一行记录,就会在该行上加上一个行号,行号从1开始,依次递增,不可跳跃</p>
<pre><code>--员工工资倒序排行
--排序操作会影响rownum的顺序
select rownum,e.* from emp e order by e.sal desc;</code></pre><p><img src="https://i.loli.net/2019/10/12/JOCK1AWyc8TQXzj.png" alt="4.png"></p>
<pre><code>--如果涉及排序,但是要使用rownum,我们可以嵌套查询
select rownum,t.* from
(select rownum,e.* from emp e order by e.sal desc) t;</code></pre><p><img src="https://i.loli.net/2019/10/12/ZdfAQt6k4eyBNzG.png" alt="5.png"></p>
<pre><code>--emp工资倒序排列后,每页5条记录,查询第二页
--rownum行号不能写上大于一个整数
select * from(
  select rownum rn,t.* from(
         select * from emp order by sal desc
  ) t where rownum&lt;11
) where rn&gt;5;</code></pre><p><strong>rownum行号不能写上大于一个整数,可以起别名,简介令它大于一个正数(把原结果再次作为子表进行操作)</strong><br><img src="https://i.loli.net/2019/10/12/1wcTNv4GbS6eZpU.png" alt="6.png"></p>
<h1 id="13-视图"><a href="#13-视图" class="headerlink" title="13.视图"></a>13.视图</h1><p>概念:视图就是提供一个查询的窗口,所有数据来自于原表</p>
<h2 id="查询语句创建表-跨用户查询select-from-scott-emp"><a href="#查询语句创建表-跨用户查询select-from-scott-emp" class="headerlink" title="查询语句创建表(跨用户查询select * from scott.emp)"></a>查询语句创建表(跨用户查询select * from scott.emp)</h2><pre><code>create table emp as select * from scott.emp</code></pre><h2 id="创建视图-必须有dba权限"><a href="#创建视图-必须有dba权限" class="headerlink" title="创建视图(必须有dba权限)"></a>创建视图(必须有dba权限)</h2><pre><code>create view v_emp as select ename,job from emp; </code></pre><h2 id="修改视图-不推荐-会把原表也修改"><a href="#修改视图-不推荐-会把原表也修改" class="headerlink" title="修改视图(不推荐,会把原表也修改)"></a>修改视图(不推荐,会把原表也修改)</h2><pre><code>update v_emp set job=&apos;CLERK&apos; where ename=&apos;ALLEN&apos;;
commit;</code></pre><h2 id="创建只读视图"><a href="#创建只读视图" class="headerlink" title="创建只读视图"></a>创建只读视图</h2><pre><code>create view v_emp1 as select ename,job from emp with read only;</code></pre><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><ol>
<li>视图可以屏蔽掉一些敏感字段</li>
<li>保证总部和分部数据及时统一</li>
</ol>
<h1 id="14-索引"><a href="#14-索引" class="headerlink" title="14.索引"></a>14.索引</h1><p>概念:在表的列上构建一个二叉树,达到大幅度提高查询效率的目的,但是索引会影响增删改的效率</p>
<h2 id="单例索引"><a href="#单例索引" class="headerlink" title="单例索引"></a>单例索引</h2><h3 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h3><pre><code>create index idx_ename on emp(ename);
--单列索引触发规则,条件必须是索引列中的原始值
--单行函数,模糊查询,都会影响索引的触发
select * from emp where ename=&apos;SCOTT&apos;</code></pre><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><h3 id="创建复合索引"><a href="#创建复合索引" class="headerlink" title="创建复合索引"></a>创建复合索引</h3><pre><code>create index idx_enamejob on emp(ename,job);
--复合索引中第一列为优先检索列
--如果要触发复合索引,必须包含有优先检索列中的原始值
select * from emp where ename=&apos;SCOTT&apos; and job=&apos;xx&apos;;--触发复合索引
select * from emp where ename=&apos;SCOTT&apos; or job=&apos;xx&apos;;--不触发索引
select * from emp where ename=&apos;SCOTT&apos;;--触发单列索引(当这一列同时有单列索引与复合索引时)</code></pre><h1 id="15-pl-sql编程语言"><a href="#15-pl-sql编程语言" class="headerlink" title="15.pl/sql编程语言"></a>15.pl/sql编程语言</h1><p>特点:    </p>
<ol>
<li>pl/sql编程语言是对sql语言的扩展,使得sql语言具有过程化编程的特性  </li>
<li>比一般的过程化编程语言更加灵活高效  </li>
<li>主要用来编写存储过程和存储函数等  </li>
</ol>
<p>程序语法：</p>
<pre><code>declare
    说明部分 （变量说明，游标申明，例外说明 〕
begin
    语句序列 （DML语句〕…
exception
    例外处理语句
End;</code></pre><h2 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h2><pre><code>--声明方法
--赋值操作可以用:=也可以使用into查询语句赋值
declare
    i number(2) := 10; 
    s varchar2(10) := &apos;kobe&apos;; 
    ena emp.ename%type; --引用型变量:相当于把emp表中的ename列的数据类型取出   
    emprow emp%rowtype; --记录型变量
begin
    dbms_output.put_line(i);
    dbms_output.put_line(s);
    select ename into ena from emp where empno = 7788;
    dbms_output.put_line(ena);
    select * into emprow from emp where empno = 7788;
    --pl/sql编程语言的连接符为 ||而不是+
    dbms_output.put_line(emprow.ename || &apos;的工作为:&apos; || emprow.job);
end;</code></pre><h2 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h2><pre><code>--输入小于18的数字,输出未成年(&amp;代表由键盘输入)
--输入大于18小于40的数字,输出中年人
--输入大于40的数字,输出老年人
declare
    i number(3) := &amp;ii;
begin
  if i&lt;18 then
    dbms_output.put_line(&apos;未成年&apos;);

  elsif i&lt;40 then
    dbms_output.put_line(&apos;中年人&apos;);
  else
    dbms_output.put_line(&apos;老年人&apos;);    
  end if;
end;</code></pre><h2 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h2><p><strong>用三种方式输出1到10十个数字</strong></p>
<pre><code>--while
declare
  i number(2) :=1;
begin
  while i&lt;11 loop
        dbms_output.put_line(i);
        i := i+1;
  end loop;
end;

--exit 循环
declare
  i number(2) :=1;
begin
  loop
    exit when i&gt;10;
    dbms_output.put_line(i);
    i := i+1;
  end loop;
end;

--for循环
declare

begin
  for i in 1..10 loop
    dbms_output.put_line(i);
  end loop;
end;</code></pre><h2 id="游标-可以存放多个对象-多行记录"><a href="#游标-可以存放多个对象-多行记录" class="headerlink" title="游标:可以存放多个对象,多行记录"></a>游标:可以存放多个对象,多行记录</h2><p>游标的使用步骤：  </p>
<ol>
<li>打开游标： open c1; (打开游标执行查询)  </li>
<li>取一行游标的值：fetch c1 into pjob; (取一行到变量中)  </li>
<li>关闭游标： close c1;(关闭游标释放资源)  </li>
<li>游标的结束方式 exit when c1%notfound  </li>
</ol>
<pre><code>--输出emp表中所有员工的姓名
declare
  cursor c1 is select * from emp;
  emprow emp%rowtype;
begin
  open c1;
       loop
         fetch c1 into emprow;
         exit when c1%notfound;
         dbms_output.put_line(emprow.ename);
       end loop;
  close c1;
end;

--给指定部门员工涨工资(带参的游标)
declare
       cursor c2(eno emp.deptno%type)
       is select empno from emp where deptno=eno;
       en emp.empno%type;
begin
  open c2(10);
       loop
          fetch c2 into en;
          exit when c2%notfound;
          update emp set sal=sal+100 where empno=en;
          commit;
       end loop;
  close c2;
end;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>概念:存储过程就是提前编译好的一段pl/sql语言,放置在数据库端,可以直接被调用,这一段pl/sql一般都是固定步骤的业务.</strong></p>
<p>创建存储过程语法：</p>
<pre><code>create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]
AS
begin
    PLSQL子程序体；
End;</code></pre><p>案例演示:</p>
<pre><code>--给指定员工涨100块钱
create or replace procedure p1(eno emp.empno%type)
as

begin
  update emp set sal=sal+100 where empno=eno;
  commit;
end;

select * from emp where empno=7788;
--测试p1
declare

begin
  p1(7788);
end;</code></pre><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><pre><code>create or replace function 函数名(Name in type, Name in type, ...) return 数据类型
 is
    结果变量 数据类型;
begin
    return(结果变量);
end函数名;</code></pre><p>通过存储函数实现计算指定员工的年薪<br>存储过程和存储函数的参数都不能带长度<br>存储函数的返回值类型不能带长度  </p>
<pre><code>create or replace function f_yearsal(eno emp.empno%type) return number
as
  s number(10);
begin
  select sal*12+nvl(comm,0) into s from emp where empno = eno;
  return s;
end;</code></pre><p>测试f_yearsal<br>存储函数在调用的时候,返回值需要接收  </p>
<pre><code>declare
  s number(10);
begin
  s := f_yearsal(7788);
  dbms_output.put_line(s);
end;</code></pre><h2 id="out类型参数的使用"><a href="#out类型参数的使用" class="headerlink" title="out类型参数的使用"></a>out类型参数的使用</h2><pre><code>--使用存储过程来算年薪
create or replace procedure p_pyearsal(eno emp.empno%type,yearsal out number)
is
  s number(10);
  c emp.comm%type;
begin
  select sal*12,nvl(comm,0) into s,c from emp where empno=eno;
  yearsal :=s+c;
end;


--测试p_pyearsal
declare
  s number(10);
begin
  p_pyearsal(7788,s);
  dbms_output.put_line(s);
end;</code></pre><p><strong>in和out类型参数的区别:<br>凡是涉及到into查询语句赋值或者:=赋值操作的参数,都必须用out来修饰</strong></p>
<h2 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h2><ol>
<li>语法区别:关键字不一样,函数比过程多了两个return</li>
<li><strong>本质区别:存储函数有返回值,而存储过程没返回值<br>(如果存储过程想实现有返回值的业务,就必须使用out类型的参数;即便是存储过程使用了out类型的参数,其本质也不是真的有了返回值,而是在存储过程内部给out类型参数赋值,在执行完毕后,我们直接拿到输出类型参数的值)</strong></li>
<li>我们可以使用存储函数有返回值的特性,来自定义函数.而存储过程不能用来自定义函数</li>
</ol>
<p>案例:查询出员工姓名,员工所在部门名称</p>
<p>传统方式实现:</p>
<pre><code>select e.ename,d.dname
from emp e,dept d
where e.deptno=d.deptno;</code></pre><p>使用存储函数实现:</p>
<pre><code>--创建一个存储函数提供一个部门编号,输出一个部门名称
create or replace function asd(dno dept.deptno%type)return dept.dname%type
is
    dna dept.dname%type; 
begin
  select dname into dna from dept where deptno=dno;
  return dna;
end;

--使用asd存储函数来实现案例需求:查询出员工姓名,员工所在部门名称
select ename,asd(deptno)
from emp;</code></pre><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>定义:就是制定一个规则,在我们做增删改操作的时候,只要满足该规则,自动触发,无需调用.</p>
<p>**两类触发器:  </p>
<ol>
<li>语句级触发器:不包含有for each row  </li>
<li>行级触发器:包含有for each row的就是行级触发器**</li>
</ol>
<p>加for each row是为了使用:old或者:new对象或者一行记录<br><img src="https://i.loli.net/2019/10/12/VHrnIFP2Byog1cT.png" alt="7.png"></p>
<p><strong>语句级触发器案例</strong></p>
<pre><code>--插入一条记录,输出一个新员工入职
create or replace trigger t1
after--插入后执行
insert--哪种语句
on person--往哪张表插
declare 

begin
  dbms_output.put_line(&apos;一个新员工入职&apos;);
end;
--触发t1
insert into person values(24,&apos;科比&apos;);
commit;</code></pre><p><strong>行级别触发器案例</strong></p>
<pre><code>--不能给员工降薪
--raise_application_error(-20001~-20999之间,&apos;错误提示信息&apos;);
create or replace trigger t2
before--更新前执行
update--使用更新语句
on emp--在哪张表更新
for each row--用来提取旧数据和新数据
declare

begin
  if :old.sal&gt;:new.sal then
    raise_application_error(-20001,&apos;不能给员工降薪&apos;);
  end if;
end;

--触发t2
update emp set sal=sal-1 where empno=7788;
commit; </code></pre><p><img src="https://i.loli.net/2019/10/12/WSlq4Jr3DOQcGIv.png" alt="8.png"></p>
<h2 id="触发器实现主键自增"><a href="#触发器实现主键自增" class="headerlink" title="触发器实现主键自增"></a>触发器实现主键自增</h2><p><strong>分析:在用户做插入操作之前,拿到即将插入的数据,给该数据中的主键列赋值</strong></p>
<pre><code>--s_person.nextval是之前创建的序列,采取增长nextval,赋值给:new将要插入的数据
create or replace trigger auid
before
insert
on person
for each row
declare

begin
  select s_person.nextval into :new.pid from dual;
end;

--使用auid实现主键自增
insert into person (pname) values (&apos;布莱恩特&apos;);
commit;</code></pre><h1 id="16-java调用存储过程和存储函数"><a href="#16-java调用存储过程和存储函数" class="headerlink" title="16.java调用存储过程和存储函数"></a>16.java调用存储过程和存储函数</h1><p>Oracle版本与对应的jar包<br>oracle10g—ojdbc14.jar<br>oracle11g—ojdbc6.jar</p>
<p>使用IDEA创建一个MAVEN工程.<br>导入依赖坐标:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.kobe&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc_oracle&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.oracle&lt;/groupId&gt;
            &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;
            &lt;version&gt;10.2.0.4.0&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;</code></pre><p>进行简单测试:</p>
<pre><code>public class OracleDemo {

    @Test
    public void javaCallOracle() throws Exception {
        //加载数据库驱动
        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
        //得到Connection连接
        Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:localhost:1521:orcl&quot;, &quot;kobe&quot;, &quot;kobe&quot;);
        //得到预编译的Statement对象
        PreparedStatement pstm = con.prepareStatement(&quot;select * from emp where empno = ?&quot;);
        //给参数赋值
        pstm.setObject(1,7788);
        //执行
        ResultSet rs = pstm.executeQuery();
        //输出结果
        while(rs.next()) {
            System.out.println(rs.getString(&quot;ename&quot;));
        }
        //释放资源
        rs.close();
        pstm.close();
        con.close();
    }
}</code></pre><p><img src="https://i.loli.net/2019/10/12/Wqlht5fTuSRVPMg.png" alt="9.png"></p>
<p>##java调用存储过程<br>    /**<br>     * java调用存储过程<br>     * 接口CallableStatement是给sql存储过程和存储函数使用的<br>     * @throws Exception<br>     */<br>    @Test<br>    public void javaCallProcedure() throws Exception {<br>        //加载数据库驱动<br>        Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>        //得到Connection连接<br>        Connection con = DriverManager.getConnection(“jdbc:oracle:thin:localhost:1521:orcl”, “kobe”, “kobe”);<br>        //得到预编译的Statement对象<br>        CallableStatement ctm = con.prepareCall(“{call p_pyearsal(?,?)}”);<br>        //给参数赋值<br>        ctm.setObject(1,7788);<br>        ctm.registerOutParameter(2, OracleTypes.NUMBER);<br>        //执行<br>        ctm.execute();<br>        //输出结果(第二个参数)<br>        System.out.println(ctm.getObject(2));<br>        //释放资源<br>        ctm.close();<br>        con.close();<br>    }</p>
<h2 id="java调用存储函数"><a href="#java调用存储函数" class="headerlink" title="java调用存储函数"></a>java调用存储函数</h2><pre><code>/**
 * java调用存储函数
 * 接口CallableStatement是给sql存储过程和存储函数使用的
 * @throws Exception
 */
@Test
public void javaCallFunction() throws Exception {
    //加载数据库驱动
    Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
    //得到Connection连接
    Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:localhost:1521:orcl&quot;, &quot;kobe&quot;, &quot;kobe&quot;);
    //得到预编译的Statement对象
    CallableStatement ctm = con.prepareCall(&quot;{? = call f_yearsal(?)}&quot;);
    //给参数赋值
    ctm.setObject(2,7788);
    ctm.registerOutParameter(1, OracleTypes.NUMBER);
    //执行
    ctm.execute();
    //输出结果(第一个参数)
    System.out.println(ctm.getObject(1));
    //释放资源
    ctm.close();
    con.close();
}</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven分模块构建</title>
    <url>/2019/10/12/Maven%E5%88%86%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="1-Maven基础知识回顾"><a href="#1-Maven基础知识回顾" class="headerlink" title="1.Maven基础知识回顾"></a>1.Maven基础知识回顾</h1><p>maven是一个项目管理工具  </p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理:"></a>依赖管理:</h2><p>maven对项目中jar包的管理过程,传统工程我们直接把jar包放置在项目中,maven工程把真正的jar包放置在仓库中,项目中只用放置jar包的坐标.</p><p>仓库的种类:本地仓库,远程仓库[私服],中央仓库.<br><strong>仓库之间的关系:</strong><br>当我们启动一个maven工程的时候,maven工程会通过pom文件中jar包的坐标去本地仓库找对应jar包<br>默认情况下,如果本地仓库没有对应jar包,maven会自动去中央仓库下载jar包到本地仓库<br>在公司中,如果本地没有对应jar包,会先从私服下载jar包,如果私服没有jar包,可以从中央仓库下载,也可以从本地上传</p><a id="more"></a>


<h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建:"></a>一键构建:</h2><p>maven自身继承了tomcat插件,可以对项目进行编译,测试,打爆,安装,发布等操作.</p>
<p><strong>maven常用命令:</strong><br>clean,compile,test,package,install,deploy</p>
<p><strong>maven三套生命周期:</strong><br>清理生命周期,默认生命周期,站点生命周期</p>
<h2 id="maven工程要导入jar包的坐标-就必须要考虑jar包冲突"><a href="#maven工程要导入jar包的坐标-就必须要考虑jar包冲突" class="headerlink" title="maven工程要导入jar包的坐标,就必须要考虑jar包冲突."></a>maven工程要导入jar包的坐标,就必须要考虑jar包冲突.</h2><pre><code>解决jar包冲突的方式一:
第一声明优先原则:
哪个jar包的坐标靠上的位置,这个jar包就是先声明的
先声明的jar包坐标下的依赖包,可以优先进入项目中

maven导入jar包中的一些概念
直接依赖:项目中直接导入的jar包就是该项目的直接项目包
传递依赖:项目中没有直接导入的jar包,可以通过项目直接依赖jar包传递到项目中去

解决jar包冲突的方式二:
路径近者优先原则:
直接依赖路径比传递依赖路径近,最终项目进入的jar包会是路径近的直接依赖包

解决jar包冲突的方式三:(推荐使用)
直接排除法:
但我们要排除某个jar包下依赖包,在配置exclusions标签的时候内部可以不写版本号,因为此时依赖包使用的版本和默认jar包一样</code></pre><h2 id="dependencyManagement标签"><a href="#dependencyManagement标签" class="headerlink" title="dependencyManagement标签"></a>dependencyManagement标签</h2><p><strong>maven工程可以分父子依赖关系的</strong>.<br>  凡是依赖别的项目后,拿到别的项目的依赖包,都属于传递依赖<br>  如:当前A项目,被B项目依赖,那么我们A项目中所有jar包都会传递到B项目中<br>  B项目开发者,如果再从项目中导入一套ssm框架的jar包,对于B项目是直接依赖<br>  那么直接依赖的jar包会把A项目传递过去的jar包覆盖掉<br>  为了防止以上情况出现,我们可以把A项目中主要jar包的坐标锁住,那么其他依赖该项目的项目中<br>  即使有同名jar包直接依赖,也无法覆盖<br>  <strong>dependencyManagement只有锁定作用,没有导入作用</strong></p>
<h1 id="2-Dao层代码编写"><a href="#2-Dao层代码编写" class="headerlink" title="2.Dao层代码编写"></a>2.Dao层代码编写</h1><p>创建接口与实体类:<br>ItemsDao:</p>
<pre><code>package com.kobe.dao;

import com.kobe.domain.Items;

public interface ItemsDao {

    Items findById(Integer id);

}</code></pre><p>Items:</p>
<pre><code>package com.kobe.domain;

import java.util.Date;

public class Items {
    private Integer id;
    private String name;
    private Double price;
    private String pic;
    private Date createtime;
    private String detail;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public String getPic() {
        return pic;
    }

    public void setPic(String pic) {
        this.pic = pic;
    }

    public Date getCreatetime() {
        return createtime;
    }

    public void setCreatetime(Date createtime) {
        this.createtime = createtime;
    }

    public String getDetail() {
        return detail;
    }

    public void setDetail(String detail) {
        this.detail = detail;
    }

    @Override
    public String toString() {
        return &quot;Items{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, price=&quot; + price +
                &quot;, pic=&apos;&quot; + pic + &apos;\&apos;&apos; +
                &quot;, createtime=&quot; + createtime +
                &quot;, detail=&apos;&quot; + detail + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}</code></pre><p>创建接口配置文件:<br>ItemsDao.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kobe.dao.ItemsDao&quot;&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;items&quot;&gt;
        SELECT * FROM items WHERE id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre><p>applicationContext.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--dao层配置文件开始--&gt;
    &lt;!--配置连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///maven&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置生产SqlSession的工厂--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--扫描pojo包,给包下所有pojo对象起别名--&gt;
        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.kobe.domain&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--扫描接口包路径,生成包下所有接口的代理对象,并放入ioc容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.kobe.dao&quot;/&gt;
    &lt;/bean&gt;


    &lt;!--dao层配置文件结束--&gt;


&lt;/beans&gt;</code></pre><h1 id="3-Service层代码编写"><a href="#3-Service层代码编写" class="headerlink" title="3.Service层代码编写"></a>3.Service层代码编写</h1><p>编写service接口与实现类</p>
<p>ItemsServiceImpl:</p>
<pre><code>@Service(&quot;itemsService&quot;)
public class ItemsServiceImpl implements ItemsService {

    @Autowired
    private ItemsDao itemsDao;

    @Override
    public Items findById(Integer id) {
        return itemsDao.findById(id);
    }
}</code></pre><p>在applicationContext.xml添加相关配置</p>
<pre><code>&lt;!--service层配置文件开始--&gt;

&lt;!--组件扫描配置--&gt;
&lt;context:component-scan base-package=&quot;com.kobe&quot;&gt;
    &lt;!--配置不扫描Controller注解--&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;

&lt;!--aop面向切面编程,切面就是切入点和通知的组合--&gt;
&lt;!--配置事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
&lt;!--配置事务的通知--&gt;
&lt;tx:advice id=&quot;advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;!--配置切入点--&gt;
    &lt;aop:pointcut id=&quot;p1&quot; expression=&quot;execution(* com.kobe.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;p1&quot;/&gt;
&lt;/aop:config&gt;

&lt;!--service层配置文件结束--&gt;</code></pre><h1 id="4-web层代码编写"><a href="#4-web层代码编写" class="headerlink" title="4.web层代码编写"></a>4.web层代码编写</h1><p>编写Controller类:</p>
<pre><code>@Controller
@RequestMapping(&quot;/items&quot;)
public class ItemsController {

    @Autowired
    private ItemsService itemsService;

    @RequestMapping(&quot;/findDetail&quot;)
    public String findDetail(Model model) {
        Items items = itemsService.findById(1);
        model.addAttribute(&quot;item&quot;,items);
        return &quot;itemDetail&quot;;
    }
}</code></pre><p>编写springmvc.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.kobe.controller&quot;/&gt;

    &lt;!--配置处理器映射器,处理器映射器,开启注解支持--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!--视图解析器--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--释放静态资源--&gt;
    &lt;mvc:default-servlet-handler/&gt;

&lt;/beans&gt;</code></pre><p>编写web.xml:</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
         version=&quot;3.0&quot;&gt;

    &lt;!--编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--配置spring核心监听器--&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!--重新指定spring配置文件的路径--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!--springmvc的核心servlet  前端控制器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>前端测试页:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt;    

&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; 
    &lt;form&gt;
        &lt;table width=&quot;100%&quot; border=1&gt;
            &lt;tr&gt;
                &lt;td&gt;商品名称&lt;/td&gt;
                &lt;td&gt; ${item.name } &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;商品价格&lt;/td&gt;
                &lt;td&gt; ${item.price } &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;生成日期&lt;/td&gt;
                &lt;td&gt; &lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;商品简介&lt;/td&gt;
                &lt;td&gt;${item.detail} &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h1 id="5-maven工程拆分与聚合的思想"><a href="#5-maven工程拆分与聚合的思想" class="headerlink" title="5.maven工程拆分与聚合的思想"></a>5.maven工程拆分与聚合的思想</h1><h2 id="拆"><a href="#拆" class="headerlink" title="拆"></a>拆</h2><p>**maven解决代码可重用和便于维护的解决方法:  </p>
<ol>
<li>maven把一个完整的项目,分成不同的独立模块,这些模块都有各自独立的坐标,哪个地方需要其中某个模块,直接引用该模块坐标即可.  </li>
<li>今后如果开发一个新项目,我们先考虑的问题不是dao,service,utils,domain如何编写,应该优先考虑dao,service,utils,domain这些模块是否已经存在,如果存在直接引用.**</li>
</ol>
<h2 id="聚"><a href="#聚" class="headerlink" title="聚"></a>聚</h2><p>我们可以把拆分零散的模块聚合到一起编写一个完整的项目,这就是maven聚合思想</p>
<p>项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service、web三个工程最终会打一个独立的war运行。</p>
<h2 id="工程与模块的区别"><a href="#工程与模块的区别" class="headerlink" title="工程与模块的区别"></a>工程与模块的区别</h2><ol>
<li><p>工程不等于完整的项目,模块也不等于完整的项目,一个完整的项目看的是代码,代码完整,就可以说是一个完整的项目<br>和此项目是工程还是模块没有关系.</p>
</li>
<li><p>工程一般只能使用自己内部资源,工程一般是独立的,工程可以和其他工程或模块建立联系关系  </p>
</li>
<li><p>模块一般不是独立的,模块一般是属于父工程的,模块一旦创建,所有父工程的资源都可以使用</p>
</li>
</ol>
<h2 id="继承与依赖"><a href="#继承与依赖" class="headerlink" title="继承与依赖"></a>继承与依赖</h2><ol>
<li><p>父子工程之间,子模块天生继承父工程,可以使用父工程所有资源</p>
</li>
<li><p>子模块之间天生没有任何关系</p>
</li>
<li><p>父子工程之间不用建立关系,继承关系是天生的不需要手动建立</p>
</li>
<li><p>平级之间的引用叫依赖,依赖是需要后天建立的</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/10/12/kTQ72bBm9WMs3Zn.png" alt="1.png"></p>
<h1 id="6-maven父子工程创建"><a href="#6-maven父子工程创建" class="headerlink" title="6.maven父子工程创建"></a>6.maven父子工程创建</h1><h2 id="maven-parent父模块"><a href="#maven-parent父模块" class="headerlink" title="maven-parent父模块"></a>maven-parent父模块</h2><ol>
<li><p>创建一个maven工程,可不选用骨架</p>
</li>
<li><p>在pom文件中导入相关依赖坐标</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></pre></li>
</ol>
<pre><code>    &lt;groupId&gt;com.kobe&lt;/groupId&gt;
    &lt;artifactId&gt;maven_parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;maven_dao&lt;/module&gt;
        &lt;module&gt;maven_service&lt;/module&gt;
        &lt;module&gt;maven_web&lt;/module&gt;
    &lt;/modules&gt;

    &lt;!-- 统一管理jar包版本 --&gt;
    &lt;properties&gt;
        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
        &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt;
        &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;
        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;
        &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;
    &lt;/properties&gt;

    &lt;!-- 锁定jar包版本 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
                &lt;version&gt;${mybatis.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;!-- 项目依赖jar包 --&gt;
    &lt;dependencies&gt;
        &lt;!-- spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.6.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;${mysql.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- log start --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;${log4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- log end --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;c3p0&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.1.2&lt;/version&gt;
            &lt;type&gt;jar&lt;/type&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;5.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.0.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;!-- 添加tomcat7插件 --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


&lt;/project&gt;</code></pre><h2 id="子模块创建"><a href="#子模块创建" class="headerlink" title="子模块创建"></a>子模块创建</h2><ol>
<li>在父工程上右击创建maven模块(无骨架)</li>
<li>将相关代码注入子工程</li>
</ol>
<h3 id="dao"><a href="#dao" class="headerlink" title="dao:"></a>dao:</h3><p>dao包下的接口与domain包JavaBean类<br>配置文件:</p>
<ol>
<li><p>接口对应的配置文件</p>
</li>
<li><p>applicationContext.xml相关配置</p>
 <?xml version="1.0" encoding="UTF-8"?>
<p> &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a></p>
<pre><code>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;!--dao层配置文件开始--&gt;
&lt;!--配置连接池--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///maven&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;

&lt;!--配置生产SqlSession的工厂--&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!--扫描pojo包,给包下所有pojo对象起别名--&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.kobe.domain&quot;/&gt;
&lt;/bean&gt;

&lt;!--扫描接口包路径,生成包下所有接口的代理对象,并放入ioc容器中--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.kobe.dao&quot;/&gt;
&lt;/bean&gt;

&lt;!--dao层配置文件结束--&gt;</code></pre></li>
</ol>
<h3 id="service"><a href="#service" class="headerlink" title="service:"></a>service:</h3><p>service包下的接口与实现类<br>配置文件:applicationContext.xml的相关配置</p>
<pre><code>&lt;!--service层配置文件开始--&gt;

&lt;!--组件扫描配置--&gt;
&lt;context:component-scan base-package=&quot;com.kobe&quot;&gt;
    &lt;!--配置不扫描Controller注解--&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;

&lt;!--aop面向切面编程,切面就是切入点和通知的组合--&gt;
&lt;!--配置事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
&lt;!--配置事务的通知--&gt;
&lt;tx:advice id=&quot;advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;!--配置切入点--&gt;
    &lt;aop:pointcut id=&quot;p1&quot; expression=&quot;execution(* com.kobe.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;p1&quot;/&gt;
&lt;/aop:config&gt;

&lt;!--service层配置文件结束--&gt;  </code></pre><p>在pom.xml中引入dao的依赖</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kobe&lt;/groupId&gt;
        &lt;artifactId&gt;maven_dao&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h3 id="web"><a href="#web" class="headerlink" title="web:"></a>web:</h3><p>Controller包下的控制器类<br>配置文件:applicationContext.xml引入dao和service的相关配置</p>
<pre><code>&lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
&lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;  </code></pre><p>springmvc.xml文件的配置:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.kobe.controller&quot;/&gt;

    &lt;!--配置处理器映射器,处理器映射器,开启注解支持--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!--视图解析器--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--释放静态资源--&gt;
    &lt;mvc:default-servlet-handler/&gt;

&lt;/beans&gt;</code></pre><p>web.xml的配置</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
         version=&quot;3.0&quot;&gt;

  &lt;!--编码过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!--配置spring核心监听器--&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;!--重新指定spring配置文件的路径--&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;!--springmvc的核心servlet  前端控制器--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>pom.xml引入service层依赖:</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kobe&lt;/groupId&gt;
        &lt;artifactId&gt;maven_service&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h1 id="7-分模块工程的三种启动方式"><a href="#7-分模块工程的三种启动方式" class="headerlink" title="7.分模块工程的三种启动方式"></a>7.分模块工程的三种启动方式</h1><h3 id="方式一-在父工程的pom-xml中配置tomcat插件运行，自动聚合并执行-推荐"><a href="#方式一-在父工程的pom-xml中配置tomcat插件运行，自动聚合并执行-推荐" class="headerlink" title="方式一:在父工程的pom.xml中配置tomcat插件运行，自动聚合并执行(推荐)"></a>方式一:在父工程的pom.xml中配置tomcat插件运行，自动聚合并执行(推荐)</h3><h3 id="方式二-在web工程的pom-xml中配置tomcat插件运行-此时需要将父工程install到本地仓库-因为运行web工程它会从本地仓库下载依赖的jar包-web依赖于service-service依赖于dao"><a href="#方式二-在web工程的pom-xml中配置tomcat插件运行-此时需要将父工程install到本地仓库-因为运行web工程它会从本地仓库下载依赖的jar包-web依赖于service-service依赖于dao" class="headerlink" title="方式二:在web工程的pom.xml中配置tomcat插件运行,此时需要将父工程install到本地仓库,因为运行web工程它会从本地仓库下载依赖的jar包(web依赖于service,service依赖于dao)"></a>方式二:在web工程的pom.xml中配置tomcat插件运行,此时需要将父工程install到本地仓库,因为运行web工程它会从本地仓库下载依赖的jar包(web依赖于service,service依赖于dao)</h3><h3 id="方式三-使用本地tomcat配置web工程来启动"><a href="#方式三-使用本地tomcat配置web工程来启动" class="headerlink" title="方式三:使用本地tomcat配置web工程来启动"></a>方式三:使用本地tomcat配置web工程来启动</h3><h1 id="8-安装第三方jar包到本地仓库"><a href="#8-安装第三方jar包到本地仓库" class="headerlink" title="8.安装第三方jar包到本地仓库"></a>8.安装第三方jar包到本地仓库</h1><h3 id="方式一-进入jar包所在目录运行"><a href="#方式一-进入jar包所在目录运行" class="headerlink" title="方式一:进入jar包所在目录运行"></a>方式一:进入jar包所在目录运行</h3><p>mvn install:install-file -DgroupId=”com.alibaba” -DartifactId=”fastjson” -Dversion=”1.1.37” -Dfile=”<br>fastjson-1.1.37.jar” -Dpackaging=”jar”</p>
<h3 id="方式二-打开cmd直接运行"><a href="#方式二-打开cmd直接运行" class="headerlink" title="方式二:打开cmd直接运行"></a>方式二:打开cmd直接运行</h3><p>mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=目标jar包路径\fastjson-1.1.37.jar</p>
<h1 id="9-安装第三方jar包到私服"><a href="#9-安装第三方jar包到私服" class="headerlink" title="9.安装第三方jar包到私服"></a>9.安装第三方jar包到私服</h1><p>在settings配置文件中添加登录私服第三方登录信息</p>
<pre><code>&lt;server&gt;
    &lt;id&gt;thirdparty&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin123&lt;/password&gt;
&lt;/server&gt;</code></pre><h3 id="方式一-进入jar包所在目录运行-1"><a href="#方式一-进入jar包所在目录运行-1" class="headerlink" title="方式一:进入jar包所在目录运行"></a>方式一:进入jar包所在目录运行</h3><p>mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=fastjson-1.1.37.jar -Durl=<a href="http://localhost:8081/nexus/content/repositories/thirdparty/" target="_blank" rel="noopener">http://localhost:8081/nexus/content/repositories/thirdparty/</a> -DrepositoryId=thirdparty</p>
<h3 id="方式二-打开cmd直接运行-1"><a href="#方式二-打开cmd直接运行-1" class="headerlink" title="方式二:打开cmd直接运行"></a>方式二:打开cmd直接运行</h3><p>mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=目标jar包路径\fastjson-1.1.37.jar -Durl=<a href="http://localhost:8081/nexus/content/repositories/thirdparty/" target="_blank" rel="noopener">http://localhost:8081/nexus/content/repositories/thirdparty/</a> -DrepositoryId=thirdparty</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene</title>
    <url>/2019/10/11/Lucene/</url>
    <content><![CDATA[<h1 id="一-什么是全文检索"><a href="#一-什么是全文检索" class="headerlink" title="一.什么是全文检索"></a>一.什么是全文检索</h1><h2 id="1-数据的分类"><a href="#1-数据的分类" class="headerlink" title="1. 数据的分类"></a>1. 数据的分类</h2><pre><code>1. 结构化数据
    格式固定-长度固定-数据类型固定
    如数据库中的数据

2. 非结构化数据
    word文档-pdf文档-邮件-html
    格式不固定-长度不固定-数据类型不固定</code></pre><h2 id="2-数据的查询"><a href="#2-数据的查询" class="headerlink" title="2.数据的查询"></a>2.数据的查询</h2><pre><code>1.结构化数据的查询
    SQL语句,查询结构化数据的方法.简单-速度快

2.非结构化数据的查询
    从文本文件中找出包含特定字符的文件
    1.目测
    2.使用程序把文档读取到内存中,然后匹配字符串,顺序扫描
    3.把非结构化数据变成结构化数据
        先根据空格进行字符串拆分,得到一个单词列表,基于单词列表创建一个索引
        然后查询索引,根据单词和文档的对应关系找到文档列表,这个过程叫全文检索

        索引:为了提高查询速度,创建某种数据结构的集合.</code></pre><a id="more"></a><h2 id="3-全文检索概念"><a href="#3-全文检索概念" class="headerlink" title="3.全文检索概念"></a>3.全文检索概念</h2><pre><code>先创建索引,然后查询索引的过程叫做全文检索
索引一次创建可以多次使用,每次查询速度都很快</code></pre><h1 id="二-全文检索的应用场景"><a href="#二-全文检索的应用场景" class="headerlink" title="二.全文检索的应用场景"></a>二.全文检索的应用场景</h1><h2 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1.搜索引擎"></a>1.搜索引擎</h2><pre><code>百度.360.搜狗.谷歌等</code></pre><h2 id="2-站内搜索"><a href="#2-站内搜索" class="headerlink" title="2.站内搜索"></a>2.站内搜索</h2><pre><code>论坛搜索.微博搜索.贴吧搜索</code></pre><h2 id="3-电商搜索"><a href="#3-电商搜索" class="headerlink" title="3.电商搜索"></a>3.电商搜索</h2><pre><code>淘宝.京东.拼多多</code></pre><h2 id="4-只要有搜索的地方-就可以使用全文检索技术"><a href="#4-只要有搜索的地方-就可以使用全文检索技术" class="headerlink" title="4.只要有搜索的地方,就可以使用全文检索技术"></a>4.只要有搜索的地方,就可以使用全文检索技术</h2><h1 id="三-什么是Lucene"><a href="#三-什么是Lucene" class="headerlink" title="三.什么是Lucene"></a>三.什么是Lucene</h1><p>Lucene是一个基于Java开发全文检索工具包</p>
<h1 id="四-Lucene实现全文检索的流程"><a href="#四-Lucene实现全文检索的流程" class="headerlink" title="四.Lucene实现全文检索的流程"></a>四.Lucene实现全文检索的流程</h1><p>流程图:</p>
<p><img src="https://i.loli.net/2019/10/12/KAjQqSBhL8YWZmt.png" alt></p>
<h2 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h2><pre><code>1.获得文档
    原始文档:要基于哪些数据来进行搜索,那这些数据就是原始文档
    搜索引擎:使用爬虫获得原始文档
    站内搜索:数据库中的数据
2.构建文档对象
    对应每个原始文档创建一个Document对象
    每个文档都有一个唯一的编号 文档id</code></pre><p><img src="https://i.loli.net/2019/10/12/ALmYdr5e6nZOasK.png" alt="2.png"></p>
<pre><code>3.分析文档
    就是分词的过程
    1.根据空格进行字符串拆分
    2.把单词统一换成小写
    3.去除标点符号
    4.去除停用词
        停用词:无意义的词
    每个关键词都封装成一个term对象
        term中包含两部分内容:
            关键词所在的域
            关键词本身
        不同的域中拆分出来的相同的关键词是不同的Term
4.创建索引
    基于关键词列表创建一个索引.保存到索引库中
    索引库中:
        索引
        Document对象
        关键词和文档的对应关系</code></pre><p><img src="https://i.loli.net/2019/10/12/T6lEvIBsD2RSjiH.png" alt="3.png"></p>
<pre><code>    注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。
传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。 
倒排索引结构是根据内容（词语）找文档，如下图：</code></pre><p><img src="https://i.loli.net/2019/10/12/mZUoV3x5OK92eWi.png" alt="4.png"></p>
<pre><code>倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。</code></pre><h2 id="2-查询索引"><a href="#2-查询索引" class="headerlink" title="2.查询索引"></a>2.查询索引</h2><pre><code>1.用户查询接口
    用户输入查询条件的地方
    如:搜索框
2.把关键词封装成一个查询对象
    查询对象:
        要查询的域
        要搜索的关键词
3.执行查询
    根据要查询的关键词到对应的域上进行搜索
    找到关键词,根据关键词找到对应的文档
4.渲染结果
    根据文档的id找到文档对象
    对关键词进行高亮显示
    分页处理
    最终展示结果</code></pre><h1 id="五-入门程序"><a href="#五-入门程序" class="headerlink" title="五.入门程序"></a>五.入门程序</h1><h2 id="1-创建索引-1"><a href="#1-创建索引-1" class="headerlink" title="1.创建索引"></a>1.创建索引</h2><pre><code>环境:
    下载Lucene.https://lucene.apache.org/
    最低jdk1.8

工程搭建:
    创建一个java工程
    添加jar:
        lucene-analyzers-common-7.4.0.jar
        lucene-core-7.4.0.jar
        commons-io.jar

步骤:
    1.创建一个Directory对象,指定索引库保存的位置
    2.基于Directory对象创建一个IndexWriter对象
    3.读取磁盘上的文件,对应每个文件创建一个文档对象
    4.向文档对象中添加域
    5.把文档对象写入索引库
    6.关闭IndexWriter对象</code></pre><p>主要代码:</p>
<pre><code>public class LuceneFirst {

    @Test
    public void createIndex()throws Exception {
        //1.创建一个Directory对象,指定索引库保存的位置
        //把索引库保存在内存中
        //Directory directory = new RAMDirectory();
        //把索引库保存在磁盘中
        Directory directory = FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath());
        //2.基于Directory对象创建一个IndexWriter对象
        IndexWriter indexWriter = new IndexWriter(directory,new IndexWriterConfig());
        //3.读取磁盘上的文件,对应每个文件创建一个文档对象
        File dir = new File(&quot;D:\\Homework\\Java\\searchsource&quot;);
        File[] files = dir.listFiles();
        for (File f : files) {
            //取文件名
            String fileName = f.getName();
            //文件路径
            String filePath = f.getPath();
            //文件的内容
            String fileContent = FileUtils.readFileToString(f, &quot;utf-8&quot;);
            //文件的大小
            long fileSize = FileUtils.sizeOf(f);
            //创建Field
            //参数1:域的名称  参数2:域的值  参数3:是否存储
            Field fieldName = new TextField(&quot;name&quot;,fileName, Field.Store.YES);
            Field fieldpath = new TextField(&quot;path&quot;,filePath, Field.Store.YES);
            Field fieldContent = new TextField(&quot;Content&quot;,fileContent, Field.Store.YES);
            Field fieldSize = new TextField(&quot;Size&quot;,fileSize+&quot;&quot;, Field.Store.YES);

            //创建文档对象
            Document document = new Document();
            //向文本对象添加域
            document.add(fieldName);
            document.add(fieldpath);
            document.add(fieldContent);
            document.add(fieldSize);
            //5.把文档对象写入索引库
            indexWriter.addDocument(document);
        }
        //6.关闭IndexWriter对象
        indexWriter.close();
    }
}</code></pre><h2 id="2-使用luke查看索引库中的内容"><a href="#2-使用luke查看索引库中的内容" class="headerlink" title="2.使用luke查看索引库中的内容"></a>2.使用luke查看索引库中的内容</h2><h2 id="3-查询索引库"><a href="#3-查询索引库" class="headerlink" title="3.查询索引库"></a>3.查询索引库</h2><pre><code>步骤:
    1.创建一个Directory对象,指定索引库的位置
    2.创建一个IndexReader对象
    3.创建一个IndexSearcher对象,构造方法中的参数就是IndexReader
    4.创建一个Query对象,TermQuery
    5.执行查询,得到一个TopDocs对象
    6.取查询结果的总记录数
    7.取文档列表
    8.打印文档中的内容
    9.关闭IndexReader对象</code></pre><p>代码:</p>
<pre><code>@Test
public void searchIndex() throws Exception {
    //1.创建一个Directory对象,指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath());
    //2.创建一个IndexReader对象
    IndexReader indexReader = DirectoryReader.open(directory);
    //3.创建一个IndexSearcher对象,构造方法中的参数就是IndexReader
    IndexSearcher indexSearcher = new IndexSearcher(indexReader);
    //4.创建一个Query对象,TermQuery
    Query query = new TermQuery(new Term(&quot;content&quot;,&quot;spring&quot;));
    //5.执行查询,得到一个TopDocs对象
    //参数1:查询对象  参数2:查询结果返回的最大纪录数
    TopDocs topDocs = indexSearcher.search(query, 10);
    //6.取查询结果的总记录数
    System.out.println(&quot;总记录数:&quot; + topDocs.totalHits);
    //7.取文档列表
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    //8.打印文档中的内容
    for (ScoreDoc scoreDoc : scoreDocs) {
        //取文档id
        int docId = scoreDoc.doc;
        //根据id取文档对象
        Document document = indexSearcher.doc(docId);
        System.out.println(document.get(&quot;name&quot;));
        System.out.println(document.get(&quot;path&quot;));
        System.out.println(document.get(&quot;size&quot;));
        //System.out.println(document.get(&quot;content&quot;));
        System.out.println(&quot;-----------------------------&quot;);
    }
    //9.关闭IndexReader对象
    indexReader.close();
}</code></pre><h1 id="六-分析器"><a href="#六-分析器" class="headerlink" title="六.分析器"></a>六.分析器</h1><p>默认使用的是标准分析器StandardAnalyzer</p>
<h2 id="1-查看分析器的分析效果"><a href="#1-查看分析器的分析效果" class="headerlink" title="1.查看分析器的分析效果"></a>1.查看分析器的分析效果</h2><pre><code>使用Analyzer对象的tokenStream方法返回一个TokenStream对象.此对象包含了最终的分词结果
实现步骤:
    1.创建一个Analyzer对象,StandardAnalyzer对象
    2.使用分析其对象的tokenStream方法返回一个TokenStream对象
    3.向TokenStream设置一个引用,相当于一个指针
    4.调用TokenStream对象的rest方法,如果不调用会抛异常
    5.使用while循环遍历TokenStream对象
    6.关闭TokenStream对象</code></pre><h2 id="2-IKAnalyze的使用方法啊-中文分析器"><a href="#2-IKAnalyze的使用方法啊-中文分析器" class="headerlink" title="2.IKAnalyze的使用方法啊(中文分析器)"></a>2.IKAnalyze的使用方法啊(中文分析器)</h2><pre><code>1.把IKAnalyze的jar包添加到工程
2.把配置文件和扩展词典添加到工程的classpath下
注:扩展词典不可以使用windows记事本编辑,保证扩展词典格式是utf-8
扩展词典:添加一些新词
停用词词典:无意义的词或者是敏感词汇</code></pre><h1 id="七-索引库的维护"><a href="#七-索引库的维护" class="headerlink" title="七.索引库的维护"></a>七.索引库的维护</h1><h2 id="1-Field域的属性"><a href="#1-Field域的属性" class="headerlink" title="1.Field域的属性"></a>1.Field域的属性</h2><pre><code>是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。

是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。
比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。

是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取
比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。

是否存储的标准：是否要将内容展示给用户</code></pre><p><img src="https://i.loli.net/2019/10/12/V1tcMAUz8kwsL3o.png" alt="5.png"></p>
<h2 id="2-添加文档代码实现"><a href="#2-添加文档代码实现" class="headerlink" title="2.添加文档代码实现"></a>2.添加文档代码实现</h2><pre><code>public void addDocument() throws Exception {
    //创建一个IndexWriter对象,使用IKAnalyzer作为分析器
    IndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath()),
            new IndexWriterConfig(new IKAnalyzer()));
    //创建一个Document对象
    Document document = new Document();
    //向document对象添加域
    document.add(new TextField(&quot;name&quot;,&quot;新添加的文件&quot;, Field.Store.YES));
    document.add(new TextField(&quot;content&quot;,&quot;新添加的文件内容&quot;, Field.Store.NO));
    document.add(new StoredField(&quot;path&quot;,&quot;D:\\Homework\\Java\\temp\\kobe&quot;));
    //把文档写入索引库
    indexWriter.addDocument(document);
    //关闭索引库
    indexWriter.close();
}</code></pre><h2 id="3-索引库删除"><a href="#3-索引库删除" class="headerlink" title="3.索引库删除"></a>3.索引库删除</h2><pre><code>public void deleteAllDocument() throws Exception {
    //删除全部文档
    indexWriter.deleteAll();
    //关闭索引库
    indexWriter.close();
}

public void deleteDocumentByQuery() throws Exception {
    //删除名字有apache的文件
    indexWriter.deleteDocuments(new Term(&quot;name&quot;,&quot;apache&quot;));
    indexWriter.close();
}</code></pre><h2 id="4-索引库的修改"><a href="#4-索引库的修改" class="headerlink" title="4.索引库的修改"></a>4.索引库的修改</h2><p>原理:先删除,后添加</p>
<pre><code>public void updateDocument() throws Exception {
    //创建一个新的文档对象
    Document document = new Document();
    //向文档对象添加域
    document.add(new TextField(&quot;name1&quot;,&quot;更新后的文档1&quot;, Field.Store.YES));
    document.add(new TextField(&quot;name2&quot;,&quot;更新后的文档2&quot;, Field.Store.YES));
    document.add(new TextField(&quot;name3&quot;,&quot;更新后的文档3&quot;, Field.Store.YES));
    //更新
    //参数1:要删除的文档  参数2:添加的文档
    indexWriter.updateDocument(new Term(&quot;name&quot;,&quot;spring&quot;),document);
    //关闭索引库
    indexWriter.close();
}</code></pre><h1 id="八-索引库的查询"><a href="#八-索引库的查询" class="headerlink" title="八.索引库的查询"></a>八.索引库的查询</h1><h2 id="1-使用Query的子类"><a href="#1-使用Query的子类" class="headerlink" title="1.使用Query的子类"></a>1.使用Query的子类</h2><pre><code>1.TermQuery
    根据关键词进行查询
    需要指定要查询的域及要查询的关键词

2.RangeQuery</code></pre><p>代码:</p>
<pre><code>public void testRangeQuery() throws Exception {
    //创建一个Query对象
    Query query = LongPoint.newRangeQuery(&quot;size&quot;, 0, 100);
    printResult(query);
}

private void printResult(Query query) throws Exception {
    //执行查询
    TopDocs topDocs = indexSearcher.search(query, 10);
    //遍历
    System.out.println(&quot;总记录数:&quot; + topDocs.totalHits);
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    for (ScoreDoc scoreDoc : scoreDocs) {
        int docId = scoreDoc.doc;
        //根据id取文档对象
        Document document = indexSearcher.doc(docId);
        System.out.println(document.get(&quot;name&quot;));
        System.out.println(document.get(&quot;path&quot;));
        System.out.println(document.get(&quot;size&quot;));
        //System.out.println(document.get(&quot;content&quot;));
        System.out.println(&quot;-----------------------------&quot;);
    }
    //9.关闭IndexReader对象
    indexReader.close();
}</code></pre><hr>
<pre><code>3.使用queryparser查询
    可以对要查询的内容先分词,然后基于分词的结果进行查询
    添加jar包
    lucene-queryparser-7.4.0.jar</code></pre><p>代码:</p>
<pre><code>public void testQueryParser() throws Exception {
    //创建一个QueryParser对象
    //参数1:默认搜索域  参数2:分析器对象
    QueryParser queryParser = new QueryParser(&quot;name&quot;,new IKAnalyzer());
    //使用QueryParser对象创建一个Query对象
    Query query = queryParser.parse(&quot;lucene是一个java开发的全文检索工具包&quot;);
    //执行查询
    printResult(query);
}</code></pre>]]></content>
      <categories>
        <category>搜索技术</category>
      </categories>
      <tags>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/10/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="换了个博客框架-之前自己做的实在是太丑了-忍不了…会陆续将之前的笔记搬运过来"><a href="#换了个博客框架-之前自己做的实在是太丑了-忍不了…会陆续将之前的笔记搬运过来" class="headerlink" title="换了个博客框架,之前自己做的实在是太丑了,忍不了…会陆续将之前的笔记搬运过来"></a>换了个博客框架,之前自己做的实在是太丑了,忍不了…会陆续将之前的笔记搬运过来</h2>]]></content>
  </entry>
</search>
