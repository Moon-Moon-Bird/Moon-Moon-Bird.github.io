<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Oracle学习笔记</title>
    <url>/2019/10/12/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-Oracle体系结构"><a href="#1-Oracle体系结构" class="headerlink" title="1.Oracle体系结构"></a>1.Oracle体系结构</h1><ol>
<li><p>数据库<br>Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。</p>
</li>
<li><p>实例<br>一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。</p>
</li>
<li><p>用户<br>用户是在实例下建立的。不同实例可以建相同名字的用户。(相当于mysql的数据库)</p>
</li>
</ol><a id="more"></a>
<ol start="4">
<li>表空间<br>表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构。每个数据库至少有一个表空间(称之为system表空间)。 每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile)。一个数据文件只能属于一个表空间。<br><img src="https://i.loli.net/2019/10/12/zZtdCAkBH92FsmS.png" alt="1.png"></li>
</ol>
<ol start="5">
<li>数据文件（dbf、ora）<br>数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。<br><img src="https://i.loli.net/2019/10/12/nd9pfuKFAZsyNqR.png" alt="2.png"><br><img src="https://i.loli.net/2019/10/12/MX7J3xNrCaVo4jK.png" alt="3.png"></li>
</ol>
<h1 id="2-表空间与用户的创建"><a href="#2-表空间与用户的创建" class="headerlink" title="2.表空间与用户的创建"></a>2.表空间与用户的创建</h1><pre><code>--创建表空间
create tablespace kobe
datafile &apos;d:\kobe.dbf&apos;
size 100m
autoextend on
next 10m;

--删除表空间
drop tablespace kobe;

--创建用户
create user kobe
identified by kobe
default tablespace kobe;

--给用户授权
--oracle数据库中常用角色
connect --连接角色,基本角色
resource --开发者角色
dba --超级管理员角色

--给kobe用户授予dba角色
grant dba to kobe;

--切换到kobe用户下</code></pre><h1 id="3-Oracle数据类型"><a href="#3-Oracle数据类型" class="headerlink" title="3.Oracle数据类型"></a>3.Oracle数据类型</h1><h2 id="Varchar，-varchar2"><a href="#Varchar，-varchar2" class="headerlink" title="Varchar， varchar2"></a>Varchar， varchar2</h2><p>表示一个字符串</p>
<h2 id="NUMBER"><a href="#NUMBER" class="headerlink" title="NUMBER"></a>NUMBER</h2><p>NUMBER(n)表示一个整数，长度是n<br>NUMBER(m,n):表示一个小数，总长度是m，小数是n，整数是m-n</p>
<h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h2><p>表示日期类型</p>
<h2 id="CLOB"><a href="#CLOB" class="headerlink" title="CLOB"></a>CLOB</h2><p>大对象，表示大文本数据类型，可存4G</p>
<h2 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a>BLOB</h2><p>大对象，表示二进制数据，可存4G</p>
<h1 id="4-表的管理"><a href="#4-表的管理" class="headerlink" title="4.表的管理"></a>4.表的管理</h1><h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><p>语法：</p>
<pre><code>Create table 表名（
字段1 数据类型 [default 默认值],
字段2 数据类型 [default 默认值],
...
字段n 数据类型 [default 默认值]
）;</code></pre><p>范例：创建person表 </p>
<pre><code>create table person( 
    pid number(10), 
    name varchar2(10), 
);</code></pre><p>表结构的修改:</p>
<pre><code>--添加一列
alter table person add (gender number(1));

--修改列类型
alter table person modify gender char(1);

--修改列名称
alter table person rename column gender to sex;

--删除一列
alter table person drop column sex;</code></pre><h2 id="表的增删改"><a href="#表的增删改" class="headerlink" title="表的增删改"></a>表的增删改</h2><pre><code>--添加一条记录
insert into person (pid,pname) values (1,&apos;张三&apos;);
commit;

--修改一条记录
update person set pname = &apos;李四&apos; where pid = 1;
commit;

--三种删除
--删除表中全部记录
delete from person;

--删除表结构
drop table person;

--先删除表,再次创建表.效果等于删除表中全部记录
--在数据量大的情况下,尤其在表中带有索引的情况下,该操作效率高
--索引可以提高查询效率,但会影响增删改效率
truncate table person;</code></pre><h1 id="5-序列"><a href="#5-序列" class="headerlink" title="5.序列"></a>5.序列</h1><p> 序列不真的属于任何一张表,但是可以逻辑和表做绑定<br> 序列:默认从1开始,依次递增,主要用来给主键赋值使用<br> dual:续表,只是为了补全语法,没有意义  </p>
<pre><code>create sequence s_person;
select s_person.nextval from dual;
--nextval :取得序列的下一个内容
--currval :取得序列的当前内容 </code></pre><p>在插入数据时需要自增的主键中可以这样使用</p>
<pre><code>--添加一条记录
insert into person (pid,pname) values (s_person.nextval,&apos;张三&apos;);
commit;</code></pre><h1 id="6-Scott用户下的表结构"><a href="#6-Scott用户下的表结构" class="headerlink" title="6.Scott用户下的表结构"></a>6.Scott用户下的表结构</h1><p>用户名:scott<br>密码:tiger</p>
<pre><code>--解锁scott用户(超级管理员权限)
alter user scott account unlock;
--解锁scott用户的密码[此句也可以用来重置密码]
alter user scott identified by tiger;</code></pre><h1 id="7-单行函数"><a href="#7-单行函数" class="headerlink" title="7.单行函数"></a>7.单行函数</h1><p>单行函数:作用于一行,返回一个值<br>多行函数:作用于多行,返回一个值</p>
<h2 id="7-1-字符函数"><a href="#7-1-字符函数" class="headerlink" title="7.1 字符函数"></a>7.1 字符函数</h2><pre><code>select upper(&apos;yes&apos;) from dual; --小写变大写
select lower(&apos;YES&apos;) from dual; --大写变小写</code></pre><h2 id="7-2-数值函数"><a href="#7-2-数值函数" class="headerlink" title="7.2 数值函数"></a>7.2 数值函数</h2><pre><code>select round(26.18,1) from dual; --四舍五入,后面的参数表示保留的小数位数
select trunc(56.16,-1) from dual; --直接截取,不四舍五入
select mod(10,3) from dual; --求余数</code></pre><h2 id="7-3-日期函数"><a href="#7-3-日期函数" class="headerlink" title="7.3 日期函数"></a>7.3 日期函数</h2><pre><code>--查询出emp表中所有员工入职距离现在几天
select sysdate-e.hiredate from emp e;

--算出明天此刻
select sysdate+1 from dual;

--查询出emp表中所有员工入职距离现在几月
select months_between(sysdate,e.hiredate) from emp e;

--查询出emp表中所有员工入职距离现在几年
select months_between(sysdate,e.hiredate)/12 from emp e;

--查询出emp表中所有员工入职距离现在几周
select round((sysdate-e.hiredate)/7) from emp e;</code></pre><h2 id="7-4-转换函数"><a href="#7-4-转换函数" class="headerlink" title="7.4 转换函数"></a>7.4 转换函数</h2><pre><code>--日期转为字符串
select to_char(sysdate,&apos;fm yyyy-mm-dd- hh:mi:ss&apos;) from dual;

--24小时计数法
select to_char(sysdate,&apos;fm yyyy-mm-dd- hh24:mi:ss&apos;) from dual;

--字符串转为日期
select to_date( &apos;2019-9-16- 21:39:54&apos;,&apos;fm yyyy-mm-dd- hh24:mi:ss&apos;) from dual;</code></pre><h2 id="7-5-通用函数"><a href="#7-5-通用函数" class="headerlink" title="7.5 通用函数"></a>7.5 通用函数</h2><pre><code>--算出emp表中所有员工的年薪
--奖金里有null值,null与任意数做运算结果都为null
select e.sal*12+nvl(e.comm,0) from emp e;</code></pre><p>–nvl(值1,值2):如果值1为null,计算用值2代替</p>
<h2 id="7-6-条件表达式"><a href="#7-6-条件表达式" class="headerlink" title="7.6 条件表达式"></a>7.6 条件表达式</h2><h3 id="通用写法-mysql和Oracle通用"><a href="#通用写法-mysql和Oracle通用" class="headerlink" title="通用写法(mysql和Oracle通用)"></a>通用写法(mysql和Oracle通用)</h3><p>–给emp表中员工起中文名</p>
<pre><code>select e.ename, 
       case e.ename
         when &apos;SMITH&apos; then &apos;科比&apos;
           when &apos;ALLEN&apos; then &apos;雷阿伦&apos;
             when &apos;WARD&apos; then &apos;韦德&apos;
               else &apos;无名&apos;
                 end
from emp e;</code></pre><p>–判断emp表中员工工资,如果高于3000显示高收入,高于1500低于3000,显示中等,<br>–其余显示低收入</p>
<pre><code>select e.ename, 
       case 
         when e.sal&gt;3000 then &apos;高收入&apos;
           when e.sal&gt;1500 then &apos;中等收入&apos;
               else &apos;低收入&apos;
                 end
from emp e;</code></pre><h2 id="Oracle专用表达式"><a href="#Oracle专用表达式" class="headerlink" title="Oracle专用表达式"></a>Oracle专用表达式</h2><p>Oracle中除了起别名,都用单引号  </p>
<pre><code>select e.ename, 
       decode(e.ename,
         &apos;SMITH&apos;,&apos;科比&apos;,
           &apos;ALLEN&apos;,&apos;雷阿伦&apos;,
             &apos;WARD&apos;,&apos;韦德&apos;,
               &apos;无名&apos;) 中文名
from emp e;</code></pre><h1 id="8-多行函数-聚合函数"><a href="#8-多行函数-聚合函数" class="headerlink" title="8.多行函数(聚合函数)"></a>8.多行函数(聚合函数)</h1><pre><code>select count(1) from emp;--查询总数量
--count(1)相当于count(主键)
select sum(sal) from emp;--工资总和
select max(sal) from emp;--最高工资
select min(sal) from emp;--最低工资
select avg(sal) from emp;--平均工资</code></pre><h1 id="9-分组查询"><a href="#9-分组查询" class="headerlink" title="9.分组查询"></a>9.分组查询</h1><p>先写</p>
<pre><code>select
from
group</code></pre><p>再补全查询内容</p>
<p><strong>查询出每个部门的平均工资</strong></p>
<pre><code>--分组查询中,出现在group by后面的原始列,才能出现在select后面
--没有出现在group by后面的列,想在select后面,必须加上聚合函数
--聚合函数的特性:把多行记录变成一个值
select e.deptno,avg(e.sal)
from emp e
group by e.deptno;</code></pre><p><strong>查询出平均工资高于2000的部门信息</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e,dept d
group by e.deptno
having avg(e.sal)&gt;2000;
--所有条件都不能使用别名来判断(where执行优于select)</code></pre><p><strong>查询出每个部门工资高于800的员工的平均工资</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e
where e.sal&gt;800
group by e.deptno;
--where是过滤分组前的数据,having是过滤分组后的数据
--表现形式:where必须在group by之前.having在group by之后</code></pre><p><strong>查询出每个部门工资高于800的员工的平均工资</strong><br><strong>再查询出平均工资高于2000的部门</strong></p>
<pre><code>select e.deptno,avg(e.sal)
from emp e
where e.sal&gt;800
group by e.deptno
having avg(e.sal)&gt;2000;</code></pre><h2 id="重点-where是过滤分组前的数据-having是过滤分组后的数据"><a href="#重点-where是过滤分组前的数据-having是过滤分组后的数据" class="headerlink" title="重点:where是过滤分组前的数据,having是过滤分组后的数据"></a>重点:where是过滤分组前的数据,having是过滤分组后的数据</h2><h1 id="10-多表查询中的一些概念"><a href="#10-多表查询中的一些概念" class="headerlink" title="10. 多表查询中的一些概念"></a>10. 多表查询中的一些概念</h1><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><pre><code>select * 
from emp e inner join dept d
on e.deptno=d.deptno;</code></pre><h2 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h2><pre><code>select *
from emp e,dept d
where e.deptno=d.deptno;</code></pre><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><pre><code>select * 
from emp e inner join dept d
on e.deptno=d.deptno;</code></pre><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><pre><code>--查询出所有部门,以及部门下的员工信息(外连接)
--右外连接(右表在左侧)
select *
from emp e right join dept d
on e.deptno=d.deptno;

--查询所有员工信息,以及员工所属部门信息
--左外连接(左表在左侧)
select *
from emp e left join dept d
on e.deptno=d.deptno;</code></pre><h2 id="oracle中专用外连接"><a href="#oracle中专用外连接" class="headerlink" title="oracle中专用外连接"></a>oracle中专用外连接</h2><pre><code>--加号在哪边,另一边就显示全数据(个人理解:加号表示可扩展的意思)
select *
from emp e,dept d
where e.deptno(+)=d.deptno;</code></pre><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接其实就是在不同的角度把一张表看成多张表</p>
<p><strong>查询出员工姓名,员工领导姓名(这两个都在同一张表)</strong></p>
<pre><code>select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr=e2.empno;</code></pre><p><strong>查询出员工姓名,员工部门名称,员工领导姓名,员工领导部门名称</strong></p>
<pre><code>select e1.ename,d1.dname,e2.ename,d2.dname
from emp e1,emp e2,dept d1,dept d2
where e1.mgr=e2.empno
and e1.deptno=d1.deptno
and e2.deptno=d2.deptno;</code></pre><p><strong>练习:查询出每个员工编号，姓名，部门名称，工资等级和他的上级领导的姓名，工资等级</strong></p>
<pre><code>select 
e1.empno 员工编号,e1.ename 员工姓名,
d.dname 部门姓名,s1.grade 工资等级,
e2.ename 领导姓名,s2.grade 领导工资等级
from emp e1,emp e2,dept d,salgrade s1,salgrade s2
where e1.mgr=e2.empno
and e1.deptno=d.deptno 
and e1.sal between s1.losal and s1.hisal
and e2.sal between s2.losal and s2.hisal</code></pre><h1 id="11-子查询"><a href="#11-子查询" class="headerlink" title="11.子查询"></a>11.子查询</h1><h2 id="返回一个值"><a href="#返回一个值" class="headerlink" title="返回一个值"></a>返回一个值</h2><pre><code>--查询出工资和scott一样的员工信息
select * from emp e where e.sal =
(select sal from emp where ename=&apos;SCOTT&apos;);</code></pre><h2 id="子查询返回一个集合"><a href="#子查询返回一个集合" class="headerlink" title="子查询返回一个集合"></a>子查询返回一个集合</h2><pre><code>--查询出工资和10号部门任意员工一样的员工信息
select * from emp where sal in
(select sal from emp where deptno=10);</code></pre><h2 id="子查询返回一张表"><a href="#子查询返回一张表" class="headerlink" title="子查询返回一张表"></a>子查询返回一张表</h2><pre><code>--查询出每个部门最低工资,和最低工资员工姓名,和该员工所在部门名称
--(1)先查询出每个部门最低工资
select deptno,min(sal) msal
from emp
group by deptno;

--(2)三表联查
select t.deptno,t.msal,e.ename,d.dname
from (select deptno,min(sal) msal
      from emp
      group by deptno) t,emp e,dept d
where t.deptno=e.deptno
and t.msal=e.sal
and e.deptno=d.deptno;</code></pre><h1 id="12-Oracle中的分页"><a href="#12-Oracle中的分页" class="headerlink" title="12.Oracle中的分页"></a>12.Oracle中的分页</h1><h2 id="rownum行号"><a href="#rownum行号" class="headerlink" title="rownum行号:"></a>rownum行号:</h2><p>当我们做select操作的时候,每查询出一行记录,就会在该行上加上一个行号,行号从1开始,依次递增,不可跳跃</p>
<pre><code>--员工工资倒序排行
--排序操作会影响rownum的顺序
select rownum,e.* from emp e order by e.sal desc;</code></pre><p><img src="https://i.loli.net/2019/10/12/JOCK1AWyc8TQXzj.png" alt="4.png"></p>
<pre><code>--如果涉及排序,但是要使用rownum,我们可以嵌套查询
select rownum,t.* from
(select rownum,e.* from emp e order by e.sal desc) t;</code></pre><p><img src="https://i.loli.net/2019/10/12/ZdfAQt6k4eyBNzG.png" alt="5.png"></p>
<pre><code>--emp工资倒序排列后,每页5条记录,查询第二页
--rownum行号不能写上大于一个整数
select * from(
  select rownum rn,t.* from(
         select * from emp order by sal desc
  ) t where rownum&lt;11
) where rn&gt;5;</code></pre><p><strong>rownum行号不能写上大于一个整数,可以起别名,简介令它大于一个正数(把原结果再次作为子表进行操作)</strong><br><img src="https://i.loli.net/2019/10/12/1wcTNv4GbS6eZpU.png" alt="6.png"></p>
<h1 id="13-视图"><a href="#13-视图" class="headerlink" title="13.视图"></a>13.视图</h1><p>概念:视图就是提供一个查询的窗口,所有数据来自于原表</p>
<h2 id="查询语句创建表-跨用户查询select-from-scott-emp"><a href="#查询语句创建表-跨用户查询select-from-scott-emp" class="headerlink" title="查询语句创建表(跨用户查询select * from scott.emp)"></a>查询语句创建表(跨用户查询select * from scott.emp)</h2><pre><code>create table emp as select * from scott.emp</code></pre><h2 id="创建视图-必须有dba权限"><a href="#创建视图-必须有dba权限" class="headerlink" title="创建视图(必须有dba权限)"></a>创建视图(必须有dba权限)</h2><pre><code>create view v_emp as select ename,job from emp; </code></pre><h2 id="修改视图-不推荐-会把原表也修改"><a href="#修改视图-不推荐-会把原表也修改" class="headerlink" title="修改视图(不推荐,会把原表也修改)"></a>修改视图(不推荐,会把原表也修改)</h2><pre><code>update v_emp set job=&apos;CLERK&apos; where ename=&apos;ALLEN&apos;;
commit;</code></pre><h2 id="创建只读视图"><a href="#创建只读视图" class="headerlink" title="创建只读视图"></a>创建只读视图</h2><pre><code>create view v_emp1 as select ename,job from emp with read only;</code></pre><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><ol>
<li>视图可以屏蔽掉一些敏感字段</li>
<li>保证总部和分部数据及时统一</li>
</ol>
<h1 id="14-索引"><a href="#14-索引" class="headerlink" title="14.索引"></a>14.索引</h1><p>概念:在表的列上构建一个二叉树,达到大幅度提高查询效率的目的,但是索引会影响增删改的效率</p>
<h2 id="单例索引"><a href="#单例索引" class="headerlink" title="单例索引"></a>单例索引</h2><h3 id="创建单列索引"><a href="#创建单列索引" class="headerlink" title="创建单列索引"></a>创建单列索引</h3><pre><code>create index idx_ename on emp(ename);
--单列索引触发规则,条件必须是索引列中的原始值
--单行函数,模糊查询,都会影响索引的触发
select * from emp where ename=&apos;SCOTT&apos;</code></pre><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><h3 id="创建复合索引"><a href="#创建复合索引" class="headerlink" title="创建复合索引"></a>创建复合索引</h3><pre><code>create index idx_enamejob on emp(ename,job);
--复合索引中第一列为优先检索列
--如果要触发复合索引,必须包含有优先检索列中的原始值
select * from emp where ename=&apos;SCOTT&apos; and job=&apos;xx&apos;;--触发复合索引
select * from emp where ename=&apos;SCOTT&apos; or job=&apos;xx&apos;;--不触发索引
select * from emp where ename=&apos;SCOTT&apos;;--触发单列索引(当这一列同时有单列索引与复合索引时)</code></pre><h1 id="15-pl-sql编程语言"><a href="#15-pl-sql编程语言" class="headerlink" title="15.pl/sql编程语言"></a>15.pl/sql编程语言</h1><p>特点:    </p>
<ol>
<li>pl/sql编程语言是对sql语言的扩展,使得sql语言具有过程化编程的特性  </li>
<li>比一般的过程化编程语言更加灵活高效  </li>
<li>主要用来编写存储过程和存储函数等  </li>
</ol>
<p>程序语法：</p>
<pre><code>declare
    说明部分 （变量说明，游标申明，例外说明 〕
begin
    语句序列 （DML语句〕…
exception
    例外处理语句
End;</code></pre><h2 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h2><pre><code>--声明方法
--赋值操作可以用:=也可以使用into查询语句赋值
declare
    i number(2) := 10; 
    s varchar2(10) := &apos;kobe&apos;; 
    ena emp.ename%type; --引用型变量:相当于把emp表中的ename列的数据类型取出   
    emprow emp%rowtype; --记录型变量
begin
    dbms_output.put_line(i);
    dbms_output.put_line(s);
    select ename into ena from emp where empno = 7788;
    dbms_output.put_line(ena);
    select * into emprow from emp where empno = 7788;
    --pl/sql编程语言的连接符为 ||而不是+
    dbms_output.put_line(emprow.ename || &apos;的工作为:&apos; || emprow.job);
end;</code></pre><h2 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h2><pre><code>--输入小于18的数字,输出未成年(&amp;代表由键盘输入)
--输入大于18小于40的数字,输出中年人
--输入大于40的数字,输出老年人
declare
    i number(3) := &amp;ii;
begin
  if i&lt;18 then
    dbms_output.put_line(&apos;未成年&apos;);

  elsif i&lt;40 then
    dbms_output.put_line(&apos;中年人&apos;);
  else
    dbms_output.put_line(&apos;老年人&apos;);    
  end if;
end;</code></pre><h2 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h2><p><strong>用三种方式输出1到10十个数字</strong></p>
<pre><code>--while
declare
  i number(2) :=1;
begin
  while i&lt;11 loop
        dbms_output.put_line(i);
        i := i+1;
  end loop;
end;

--exit 循环
declare
  i number(2) :=1;
begin
  loop
    exit when i&gt;10;
    dbms_output.put_line(i);
    i := i+1;
  end loop;
end;

--for循环
declare

begin
  for i in 1..10 loop
    dbms_output.put_line(i);
  end loop;
end;</code></pre><h2 id="游标-可以存放多个对象-多行记录"><a href="#游标-可以存放多个对象-多行记录" class="headerlink" title="游标:可以存放多个对象,多行记录"></a>游标:可以存放多个对象,多行记录</h2><p>游标的使用步骤：  </p>
<ol>
<li>打开游标： open c1; (打开游标执行查询)  </li>
<li>取一行游标的值：fetch c1 into pjob; (取一行到变量中)  </li>
<li>关闭游标： close c1;(关闭游标释放资源)  </li>
<li>游标的结束方式 exit when c1%notfound  </li>
</ol>
<pre><code>--输出emp表中所有员工的姓名
declare
  cursor c1 is select * from emp;
  emprow emp%rowtype;
begin
  open c1;
       loop
         fetch c1 into emprow;
         exit when c1%notfound;
         dbms_output.put_line(emprow.ename);
       end loop;
  close c1;
end;

--给指定部门员工涨工资(带参的游标)
declare
       cursor c2(eno emp.deptno%type)
       is select empno from emp where deptno=eno;
       en emp.empno%type;
begin
  open c2(10);
       loop
          fetch c2 into en;
          exit when c2%notfound;
          update emp set sal=sal+100 where empno=en;
          commit;
       end loop;
  close c2;
end;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>概念:存储过程就是提前编译好的一段pl/sql语言,放置在数据库端,可以直接被调用,这一段pl/sql一般都是固定步骤的业务.</strong></p>
<p>创建存储过程语法：</p>
<pre><code>create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]
AS
begin
    PLSQL子程序体；
End;</code></pre><p>案例演示:</p>
<pre><code>--给指定员工涨100块钱
create or replace procedure p1(eno emp.empno%type)
as

begin
  update emp set sal=sal+100 where empno=eno;
  commit;
end;

select * from emp where empno=7788;
--测试p1
declare

begin
  p1(7788);
end;</code></pre><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><pre><code>create or replace function 函数名(Name in type, Name in type, ...) return 数据类型
 is
    结果变量 数据类型;
begin
    return(结果变量);
end函数名;</code></pre><p>通过存储函数实现计算指定员工的年薪<br>存储过程和存储函数的参数都不能带长度<br>存储函数的返回值类型不能带长度  </p>
<pre><code>create or replace function f_yearsal(eno emp.empno%type) return number
as
  s number(10);
begin
  select sal*12+nvl(comm,0) into s from emp where empno = eno;
  return s;
end;</code></pre><p>测试f_yearsal<br>存储函数在调用的时候,返回值需要接收  </p>
<pre><code>declare
  s number(10);
begin
  s := f_yearsal(7788);
  dbms_output.put_line(s);
end;</code></pre><h2 id="out类型参数的使用"><a href="#out类型参数的使用" class="headerlink" title="out类型参数的使用"></a>out类型参数的使用</h2><pre><code>--使用存储过程来算年薪
create or replace procedure p_pyearsal(eno emp.empno%type,yearsal out number)
is
  s number(10);
  c emp.comm%type;
begin
  select sal*12,nvl(comm,0) into s,c from emp where empno=eno;
  yearsal :=s+c;
end;


--测试p_pyearsal
declare
  s number(10);
begin
  p_pyearsal(7788,s);
  dbms_output.put_line(s);
end;</code></pre><p><strong>in和out类型参数的区别:<br>凡是涉及到into查询语句赋值或者:=赋值操作的参数,都必须用out来修饰</strong></p>
<h2 id="存储过程和存储函数的区别"><a href="#存储过程和存储函数的区别" class="headerlink" title="存储过程和存储函数的区别"></a>存储过程和存储函数的区别</h2><ol>
<li>语法区别:关键字不一样,函数比过程多了两个return</li>
<li><strong>本质区别:存储函数有返回值,而存储过程没返回值<br>(如果存储过程想实现有返回值的业务,就必须使用out类型的参数;即便是存储过程使用了out类型的参数,其本质也不是真的有了返回值,而是在存储过程内部给out类型参数赋值,在执行完毕后,我们直接拿到输出类型参数的值)</strong></li>
<li>我们可以使用存储函数有返回值的特性,来自定义函数.而存储过程不能用来自定义函数</li>
</ol>
<p>案例:查询出员工姓名,员工所在部门名称</p>
<p>传统方式实现:</p>
<pre><code>select e.ename,d.dname
from emp e,dept d
where e.deptno=d.deptno;</code></pre><p>使用存储函数实现:</p>
<pre><code>--创建一个存储函数提供一个部门编号,输出一个部门名称
create or replace function asd(dno dept.deptno%type)return dept.dname%type
is
    dna dept.dname%type; 
begin
  select dname into dna from dept where deptno=dno;
  return dna;
end;

--使用asd存储函数来实现案例需求:查询出员工姓名,员工所在部门名称
select ename,asd(deptno)
from emp;</code></pre><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>定义:就是制定一个规则,在我们做增删改操作的时候,只要满足该规则,自动触发,无需调用.</p>
<p>**两类触发器:  </p>
<ol>
<li>语句级触发器:不包含有for each row  </li>
<li>行级触发器:包含有for each row的就是行级触发器**</li>
</ol>
<p>加for each row是为了使用:old或者:new对象或者一行记录<br><img src="https://i.loli.net/2019/10/12/VHrnIFP2Byog1cT.png" alt="7.png"></p>
<p><strong>语句级触发器案例</strong></p>
<pre><code>--插入一条记录,输出一个新员工入职
create or replace trigger t1
after--插入后执行
insert--哪种语句
on person--往哪张表插
declare 

begin
  dbms_output.put_line(&apos;一个新员工入职&apos;);
end;
--触发t1
insert into person values(24,&apos;科比&apos;);
commit;</code></pre><p><strong>行级别触发器案例</strong></p>
<pre><code>--不能给员工降薪
--raise_application_error(-20001~-20999之间,&apos;错误提示信息&apos;);
create or replace trigger t2
before--更新前执行
update--使用更新语句
on emp--在哪张表更新
for each row--用来提取旧数据和新数据
declare

begin
  if :old.sal&gt;:new.sal then
    raise_application_error(-20001,&apos;不能给员工降薪&apos;);
  end if;
end;

--触发t2
update emp set sal=sal-1 where empno=7788;
commit; </code></pre><p><img src="https://i.loli.net/2019/10/12/WSlq4Jr3DOQcGIv.png" alt="8.png"></p>
<h2 id="触发器实现主键自增"><a href="#触发器实现主键自增" class="headerlink" title="触发器实现主键自增"></a>触发器实现主键自增</h2><p><strong>分析:在用户做插入操作之前,拿到即将插入的数据,给该数据中的主键列赋值</strong></p>
<pre><code>--s_person.nextval是之前创建的序列,采取增长nextval,赋值给:new将要插入的数据
create or replace trigger auid
before
insert
on person
for each row
declare

begin
  select s_person.nextval into :new.pid from dual;
end;

--使用auid实现主键自增
insert into person (pname) values (&apos;布莱恩特&apos;);
commit;</code></pre><h1 id="16-java调用存储过程和存储函数"><a href="#16-java调用存储过程和存储函数" class="headerlink" title="16.java调用存储过程和存储函数"></a>16.java调用存储过程和存储函数</h1><p>Oracle版本与对应的jar包<br>oracle10g—ojdbc14.jar<br>oracle11g—ojdbc6.jar</p>
<p>使用IDEA创建一个MAVEN工程.<br>导入依赖坐标:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.kobe&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc_oracle&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.oracle&lt;/groupId&gt;
            &lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;
            &lt;version&gt;10.2.0.4.0&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;</code></pre><p>进行简单测试:</p>
<pre><code>public class OracleDemo {

    @Test
    public void javaCallOracle() throws Exception {
        //加载数据库驱动
        Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
        //得到Connection连接
        Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:localhost:1521:orcl&quot;, &quot;kobe&quot;, &quot;kobe&quot;);
        //得到预编译的Statement对象
        PreparedStatement pstm = con.prepareStatement(&quot;select * from emp where empno = ?&quot;);
        //给参数赋值
        pstm.setObject(1,7788);
        //执行
        ResultSet rs = pstm.executeQuery();
        //输出结果
        while(rs.next()) {
            System.out.println(rs.getString(&quot;ename&quot;));
        }
        //释放资源
        rs.close();
        pstm.close();
        con.close();
    }
}</code></pre><p><img src="https://i.loli.net/2019/10/12/Wqlht5fTuSRVPMg.png" alt="9.png"></p>
<p>##java调用存储过程<br>    /**<br>     * java调用存储过程<br>     * 接口CallableStatement是给sql存储过程和存储函数使用的<br>     * @throws Exception<br>     */<br>    @Test<br>    public void javaCallProcedure() throws Exception {<br>        //加载数据库驱动<br>        Class.forName(“oracle.jdbc.driver.OracleDriver”);<br>        //得到Connection连接<br>        Connection con = DriverManager.getConnection(“jdbc:oracle:thin:localhost:1521:orcl”, “kobe”, “kobe”);<br>        //得到预编译的Statement对象<br>        CallableStatement ctm = con.prepareCall(“{call p_pyearsal(?,?)}”);<br>        //给参数赋值<br>        ctm.setObject(1,7788);<br>        ctm.registerOutParameter(2, OracleTypes.NUMBER);<br>        //执行<br>        ctm.execute();<br>        //输出结果(第二个参数)<br>        System.out.println(ctm.getObject(2));<br>        //释放资源<br>        ctm.close();<br>        con.close();<br>    }</p>
<h2 id="java调用存储函数"><a href="#java调用存储函数" class="headerlink" title="java调用存储函数"></a>java调用存储函数</h2><pre><code>/**
 * java调用存储函数
 * 接口CallableStatement是给sql存储过程和存储函数使用的
 * @throws Exception
 */
@Test
public void javaCallFunction() throws Exception {
    //加载数据库驱动
    Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);
    //得到Connection连接
    Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:localhost:1521:orcl&quot;, &quot;kobe&quot;, &quot;kobe&quot;);
    //得到预编译的Statement对象
    CallableStatement ctm = con.prepareCall(&quot;{? = call f_yearsal(?)}&quot;);
    //给参数赋值
    ctm.setObject(2,7788);
    ctm.registerOutParameter(1, OracleTypes.NUMBER);
    //执行
    ctm.execute();
    //输出结果(第一个参数)
    System.out.println(ctm.getObject(1));
    //释放资源
    ctm.close();
    con.close();
}</code></pre>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven分模块构建</title>
    <url>/2019/10/12/Maven%E5%88%86%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="1-Maven基础知识回顾"><a href="#1-Maven基础知识回顾" class="headerlink" title="1.Maven基础知识回顾"></a>1.Maven基础知识回顾</h1><p>maven是一个项目管理工具  </p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理:"></a>依赖管理:</h2><p>maven对项目中jar包的管理过程,传统工程我们直接把jar包放置在项目中,maven工程把真正的jar包放置在仓库中,项目中只用放置jar包的坐标.</p><p>仓库的种类:本地仓库,远程仓库[私服],中央仓库.<br><strong>仓库之间的关系:</strong><br>当我们启动一个maven工程的时候,maven工程会通过pom文件中jar包的坐标去本地仓库找对应jar包<br>默认情况下,如果本地仓库没有对应jar包,maven会自动去中央仓库下载jar包到本地仓库<br>在公司中,如果本地没有对应jar包,会先从私服下载jar包,如果私服没有jar包,可以从中央仓库下载,也可以从本地上传</p><a id="more"></a>


<h2 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建:"></a>一键构建:</h2><p>maven自身继承了tomcat插件,可以对项目进行编译,测试,打爆,安装,发布等操作.</p>
<p><strong>maven常用命令:</strong><br>clean,compile,test,package,install,deploy</p>
<p><strong>maven三套生命周期:</strong><br>清理生命周期,默认生命周期,站点生命周期</p>
<h2 id="maven工程要导入jar包的坐标-就必须要考虑jar包冲突"><a href="#maven工程要导入jar包的坐标-就必须要考虑jar包冲突" class="headerlink" title="maven工程要导入jar包的坐标,就必须要考虑jar包冲突."></a>maven工程要导入jar包的坐标,就必须要考虑jar包冲突.</h2><pre><code>解决jar包冲突的方式一:
第一声明优先原则:
哪个jar包的坐标靠上的位置,这个jar包就是先声明的
先声明的jar包坐标下的依赖包,可以优先进入项目中

maven导入jar包中的一些概念
直接依赖:项目中直接导入的jar包就是该项目的直接项目包
传递依赖:项目中没有直接导入的jar包,可以通过项目直接依赖jar包传递到项目中去

解决jar包冲突的方式二:
路径近者优先原则:
直接依赖路径比传递依赖路径近,最终项目进入的jar包会是路径近的直接依赖包

解决jar包冲突的方式三:(推荐使用)
直接排除法:
但我们要排除某个jar包下依赖包,在配置exclusions标签的时候内部可以不写版本号,因为此时依赖包使用的版本和默认jar包一样</code></pre><h2 id="dependencyManagement标签"><a href="#dependencyManagement标签" class="headerlink" title="dependencyManagement标签"></a>dependencyManagement标签</h2><p><strong>maven工程可以分父子依赖关系的</strong>.<br>  凡是依赖别的项目后,拿到别的项目的依赖包,都属于传递依赖<br>  如:当前A项目,被B项目依赖,那么我们A项目中所有jar包都会传递到B项目中<br>  B项目开发者,如果再从项目中导入一套ssm框架的jar包,对于B项目是直接依赖<br>  那么直接依赖的jar包会把A项目传递过去的jar包覆盖掉<br>  为了防止以上情况出现,我们可以把A项目中主要jar包的坐标锁住,那么其他依赖该项目的项目中<br>  即使有同名jar包直接依赖,也无法覆盖<br>  <strong>dependencyManagement只有锁定作用,没有导入作用</strong></p>
<h1 id="2-Dao层代码编写"><a href="#2-Dao层代码编写" class="headerlink" title="2.Dao层代码编写"></a>2.Dao层代码编写</h1><p>创建接口与实体类:<br>ItemsDao:</p>
<pre><code>package com.kobe.dao;

import com.kobe.domain.Items;

public interface ItemsDao {

    Items findById(Integer id);

}</code></pre><p>Items:</p>
<pre><code>package com.kobe.domain;

import java.util.Date;

public class Items {
    private Integer id;
    private String name;
    private Double price;
    private String pic;
    private Date createtime;
    private String detail;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public String getPic() {
        return pic;
    }

    public void setPic(String pic) {
        this.pic = pic;
    }

    public Date getCreatetime() {
        return createtime;
    }

    public void setCreatetime(Date createtime) {
        this.createtime = createtime;
    }

    public String getDetail() {
        return detail;
    }

    public void setDetail(String detail) {
        this.detail = detail;
    }

    @Override
    public String toString() {
        return &quot;Items{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
                &quot;, price=&quot; + price +
                &quot;, pic=&apos;&quot; + pic + &apos;\&apos;&apos; +
                &quot;, createtime=&quot; + createtime +
                &quot;, detail=&apos;&quot; + detail + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}</code></pre><p>创建接口配置文件:<br>ItemsDao.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kobe.dao.ItemsDao&quot;&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;items&quot;&gt;
        SELECT * FROM items WHERE id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre><p>applicationContext.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--dao层配置文件开始--&gt;
    &lt;!--配置连接池--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///maven&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置生产SqlSession的工厂--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--扫描pojo包,给包下所有pojo对象起别名--&gt;
        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.kobe.domain&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--扫描接口包路径,生成包下所有接口的代理对象,并放入ioc容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.kobe.dao&quot;/&gt;
    &lt;/bean&gt;


    &lt;!--dao层配置文件结束--&gt;


&lt;/beans&gt;</code></pre><h1 id="3-Service层代码编写"><a href="#3-Service层代码编写" class="headerlink" title="3.Service层代码编写"></a>3.Service层代码编写</h1><p>编写service接口与实现类</p>
<p>ItemsServiceImpl:</p>
<pre><code>@Service(&quot;itemsService&quot;)
public class ItemsServiceImpl implements ItemsService {

    @Autowired
    private ItemsDao itemsDao;

    @Override
    public Items findById(Integer id) {
        return itemsDao.findById(id);
    }
}</code></pre><p>在applicationContext.xml添加相关配置</p>
<pre><code>&lt;!--service层配置文件开始--&gt;

&lt;!--组件扫描配置--&gt;
&lt;context:component-scan base-package=&quot;com.kobe&quot;&gt;
    &lt;!--配置不扫描Controller注解--&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;

&lt;!--aop面向切面编程,切面就是切入点和通知的组合--&gt;
&lt;!--配置事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
&lt;!--配置事务的通知--&gt;
&lt;tx:advice id=&quot;advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;!--配置切入点--&gt;
    &lt;aop:pointcut id=&quot;p1&quot; expression=&quot;execution(* com.kobe.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;p1&quot;/&gt;
&lt;/aop:config&gt;

&lt;!--service层配置文件结束--&gt;</code></pre><h1 id="4-web层代码编写"><a href="#4-web层代码编写" class="headerlink" title="4.web层代码编写"></a>4.web层代码编写</h1><p>编写Controller类:</p>
<pre><code>@Controller
@RequestMapping(&quot;/items&quot;)
public class ItemsController {

    @Autowired
    private ItemsService itemsService;

    @RequestMapping(&quot;/findDetail&quot;)
    public String findDetail(Model model) {
        Items items = itemsService.findById(1);
        model.addAttribute(&quot;item&quot;,items);
        return &quot;itemDetail&quot;;
    }
}</code></pre><p>编写springmvc.xml:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.kobe.controller&quot;/&gt;

    &lt;!--配置处理器映射器,处理器映射器,开启注解支持--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!--视图解析器--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--释放静态资源--&gt;
    &lt;mvc:default-servlet-handler/&gt;

&lt;/beans&gt;</code></pre><p>编写web.xml:</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
         version=&quot;3.0&quot;&gt;

    &lt;!--编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--配置spring核心监听器--&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;!--重新指定spring配置文件的路径--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!--springmvc的核心servlet  前端控制器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>前端测试页:</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt;    

&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt; 
    &lt;form&gt;
        &lt;table width=&quot;100%&quot; border=1&gt;
            &lt;tr&gt;
                &lt;td&gt;商品名称&lt;/td&gt;
                &lt;td&gt; ${item.name } &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;商品价格&lt;/td&gt;
                &lt;td&gt; ${item.price } &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;生成日期&lt;/td&gt;
                &lt;td&gt; &lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;商品简介&lt;/td&gt;
                &lt;td&gt;${item.detail} &lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h1 id="5-maven工程拆分与聚合的思想"><a href="#5-maven工程拆分与聚合的思想" class="headerlink" title="5.maven工程拆分与聚合的思想"></a>5.maven工程拆分与聚合的思想</h1><h2 id="拆"><a href="#拆" class="headerlink" title="拆"></a>拆</h2><p>**maven解决代码可重用和便于维护的解决方法:  </p>
<ol>
<li>maven把一个完整的项目,分成不同的独立模块,这些模块都有各自独立的坐标,哪个地方需要其中某个模块,直接引用该模块坐标即可.  </li>
<li>今后如果开发一个新项目,我们先考虑的问题不是dao,service,utils,domain如何编写,应该优先考虑dao,service,utils,domain这些模块是否已经存在,如果存在直接引用.**</li>
</ol>
<h2 id="聚"><a href="#聚" class="headerlink" title="聚"></a>聚</h2><p>我们可以把拆分零散的模块聚合到一起编写一个完整的项目,这就是maven聚合思想</p>
<p>项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service、web三个工程最终会打一个独立的war运行。</p>
<h2 id="工程与模块的区别"><a href="#工程与模块的区别" class="headerlink" title="工程与模块的区别"></a>工程与模块的区别</h2><ol>
<li><p>工程不等于完整的项目,模块也不等于完整的项目,一个完整的项目看的是代码,代码完整,就可以说是一个完整的项目<br>和此项目是工程还是模块没有关系.</p>
</li>
<li><p>工程一般只能使用自己内部资源,工程一般是独立的,工程可以和其他工程或模块建立联系关系  </p>
</li>
<li><p>模块一般不是独立的,模块一般是属于父工程的,模块一旦创建,所有父工程的资源都可以使用</p>
</li>
</ol>
<h2 id="继承与依赖"><a href="#继承与依赖" class="headerlink" title="继承与依赖"></a>继承与依赖</h2><ol>
<li><p>父子工程之间,子模块天生继承父工程,可以使用父工程所有资源</p>
</li>
<li><p>子模块之间天生没有任何关系</p>
</li>
<li><p>父子工程之间不用建立关系,继承关系是天生的不需要手动建立</p>
</li>
<li><p>平级之间的引用叫依赖,依赖是需要后天建立的</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/10/12/kTQ72bBm9WMs3Zn.png" alt="1.png"></p>
<h1 id="6-maven父子工程创建"><a href="#6-maven父子工程创建" class="headerlink" title="6.maven父子工程创建"></a>6.maven父子工程创建</h1><h2 id="maven-parent父模块"><a href="#maven-parent父模块" class="headerlink" title="maven-parent父模块"></a>maven-parent父模块</h2><ol>
<li><p>创建一个maven工程,可不选用骨架</p>
</li>
<li><p>在pom文件中导入相关依赖坐标</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code></pre></li>
</ol>
<pre><code>    &lt;groupId&gt;com.kobe&lt;/groupId&gt;
    &lt;artifactId&gt;maven_parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;maven_dao&lt;/module&gt;
        &lt;module&gt;maven_service&lt;/module&gt;
        &lt;module&gt;maven_web&lt;/module&gt;
    &lt;/modules&gt;

    &lt;!-- 统一管理jar包版本 --&gt;
    &lt;properties&gt;
        &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
        &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;
        &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;
        &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt;
        &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;
        &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;
        &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;
    &lt;/properties&gt;

    &lt;!-- 锁定jar包版本 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
                &lt;version&gt;${spring.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
                &lt;version&gt;${mybatis.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;!-- 项目依赖jar包 --&gt;
    &lt;dependencies&gt;
        &lt;!-- spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.6.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;${mysql.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- log start --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;${log4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;${slf4j.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- log end --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;${mybatis.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;1.3.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;c3p0&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.1.2&lt;/version&gt;
            &lt;type&gt;jar&lt;/type&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
            &lt;version&gt;5.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;${spring.security.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.0.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;!-- 添加tomcat7插件 --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


&lt;/project&gt;</code></pre><h2 id="子模块创建"><a href="#子模块创建" class="headerlink" title="子模块创建"></a>子模块创建</h2><ol>
<li>在父工程上右击创建maven模块(无骨架)</li>
<li>将相关代码注入子工程</li>
</ol>
<h3 id="dao"><a href="#dao" class="headerlink" title="dao:"></a>dao:</h3><p>dao包下的接口与domain包JavaBean类<br>配置文件:</p>
<ol>
<li><p>接口对应的配置文件</p>
</li>
<li><p>applicationContext.xml相关配置</p>
 <?xml version="1.0" encoding="UTF-8"?>
<p> &lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans&quot;</a></p>
<pre><code>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;!--dao层配置文件开始--&gt;
&lt;!--配置连接池--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///maven&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;

&lt;!--配置生产SqlSession的工厂--&gt;
&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;!--扫描pojo包,给包下所有pojo对象起别名--&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.kobe.domain&quot;/&gt;
&lt;/bean&gt;

&lt;!--扫描接口包路径,生成包下所有接口的代理对象,并放入ioc容器中--&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.kobe.dao&quot;/&gt;
&lt;/bean&gt;

&lt;!--dao层配置文件结束--&gt;</code></pre></li>
</ol>
<h3 id="service"><a href="#service" class="headerlink" title="service:"></a>service:</h3><p>service包下的接口与实现类<br>配置文件:applicationContext.xml的相关配置</p>
<pre><code>&lt;!--service层配置文件开始--&gt;

&lt;!--组件扫描配置--&gt;
&lt;context:component-scan base-package=&quot;com.kobe&quot;&gt;
    &lt;!--配置不扫描Controller注解--&gt;
    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;

&lt;!--aop面向切面编程,切面就是切入点和通知的组合--&gt;
&lt;!--配置事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
&lt;!--配置事务的通知--&gt;
&lt;tx:advice id=&quot;advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--配置切面--&gt;
&lt;aop:config&gt;
    &lt;!--配置切入点--&gt;
    &lt;aop:pointcut id=&quot;p1&quot; expression=&quot;execution(* com.kobe.service.impl.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;p1&quot;/&gt;
&lt;/aop:config&gt;

&lt;!--service层配置文件结束--&gt;  </code></pre><p>在pom.xml中引入dao的依赖</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kobe&lt;/groupId&gt;
        &lt;artifactId&gt;maven_dao&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h3 id="web"><a href="#web" class="headerlink" title="web:"></a>web:</h3><p>Controller包下的控制器类<br>配置文件:applicationContext.xml引入dao和service的相关配置</p>
<pre><code>&lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
&lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;  </code></pre><p>springmvc.xml文件的配置:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context.xsd
                http://www.springframework.org/schema/aop
                http://www.springframework.org/schema/aop/spring-aop.xsd
                http://www.springframework.org/schema/tx
                http://www.springframework.org/schema/tx/spring-tx.xsd
                http://www.springframework.org/schema/mvc
                http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--组件扫描--&gt;
    &lt;context:component-scan base-package=&quot;com.kobe.controller&quot;/&gt;

    &lt;!--配置处理器映射器,处理器映射器,开启注解支持--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!--视图解析器--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--释放静态资源--&gt;
    &lt;mvc:default-servlet-handler/&gt;

&lt;/beans&gt;</code></pre><p>web.xml的配置</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
         version=&quot;3.0&quot;&gt;

  &lt;!--编码过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!--配置spring核心监听器--&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;!--重新指定spring配置文件的路径--&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;!--springmvc的核心servlet  前端控制器--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>pom.xml引入service层依赖:</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.kobe&lt;/groupId&gt;
        &lt;artifactId&gt;maven_service&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h1 id="7-分模块工程的三种启动方式"><a href="#7-分模块工程的三种启动方式" class="headerlink" title="7.分模块工程的三种启动方式"></a>7.分模块工程的三种启动方式</h1><h3 id="方式一-在父工程的pom-xml中配置tomcat插件运行，自动聚合并执行-推荐"><a href="#方式一-在父工程的pom-xml中配置tomcat插件运行，自动聚合并执行-推荐" class="headerlink" title="方式一:在父工程的pom.xml中配置tomcat插件运行，自动聚合并执行(推荐)"></a>方式一:在父工程的pom.xml中配置tomcat插件运行，自动聚合并执行(推荐)</h3><h3 id="方式二-在web工程的pom-xml中配置tomcat插件运行-此时需要将父工程install到本地仓库-因为运行web工程它会从本地仓库下载依赖的jar包-web依赖于service-service依赖于dao"><a href="#方式二-在web工程的pom-xml中配置tomcat插件运行-此时需要将父工程install到本地仓库-因为运行web工程它会从本地仓库下载依赖的jar包-web依赖于service-service依赖于dao" class="headerlink" title="方式二:在web工程的pom.xml中配置tomcat插件运行,此时需要将父工程install到本地仓库,因为运行web工程它会从本地仓库下载依赖的jar包(web依赖于service,service依赖于dao)"></a>方式二:在web工程的pom.xml中配置tomcat插件运行,此时需要将父工程install到本地仓库,因为运行web工程它会从本地仓库下载依赖的jar包(web依赖于service,service依赖于dao)</h3><h3 id="方式三-使用本地tomcat配置web工程来启动"><a href="#方式三-使用本地tomcat配置web工程来启动" class="headerlink" title="方式三:使用本地tomcat配置web工程来启动"></a>方式三:使用本地tomcat配置web工程来启动</h3><h1 id="8-安装第三方jar包到本地仓库"><a href="#8-安装第三方jar包到本地仓库" class="headerlink" title="8.安装第三方jar包到本地仓库"></a>8.安装第三方jar包到本地仓库</h1><h3 id="方式一-进入jar包所在目录运行"><a href="#方式一-进入jar包所在目录运行" class="headerlink" title="方式一:进入jar包所在目录运行"></a>方式一:进入jar包所在目录运行</h3><p>mvn install:install-file -DgroupId=”com.alibaba” -DartifactId=”fastjson” -Dversion=”1.1.37” -Dfile=”<br>fastjson-1.1.37.jar” -Dpackaging=”jar”</p>
<h3 id="方式二-打开cmd直接运行"><a href="#方式二-打开cmd直接运行" class="headerlink" title="方式二:打开cmd直接运行"></a>方式二:打开cmd直接运行</h3><p>mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=目标jar包路径\fastjson-1.1.37.jar</p>
<h1 id="9-安装第三方jar包到私服"><a href="#9-安装第三方jar包到私服" class="headerlink" title="9.安装第三方jar包到私服"></a>9.安装第三方jar包到私服</h1><p>在settings配置文件中添加登录私服第三方登录信息</p>
<pre><code>&lt;server&gt;
    &lt;id&gt;thirdparty&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin123&lt;/password&gt;
&lt;/server&gt;</code></pre><h3 id="方式一-进入jar包所在目录运行-1"><a href="#方式一-进入jar包所在目录运行-1" class="headerlink" title="方式一:进入jar包所在目录运行"></a>方式一:进入jar包所在目录运行</h3><p>mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=fastjson-1.1.37.jar -Durl=<a href="http://localhost:8081/nexus/content/repositories/thirdparty/" target="_blank" rel="noopener">http://localhost:8081/nexus/content/repositories/thirdparty/</a> -DrepositoryId=thirdparty</p>
<h3 id="方式二-打开cmd直接运行-1"><a href="#方式二-打开cmd直接运行-1" class="headerlink" title="方式二:打开cmd直接运行"></a>方式二:打开cmd直接运行</h3><p>mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 -Dpackaging=jar -Dfile=目标jar包路径\fastjson-1.1.37.jar -Durl=<a href="http://localhost:8081/nexus/content/repositories/thirdparty/" target="_blank" rel="noopener">http://localhost:8081/nexus/content/repositories/thirdparty/</a> -DrepositoryId=thirdparty</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene</title>
    <url>/2019/10/11/Lucene/</url>
    <content><![CDATA[<h1 id="一-什么是全文检索"><a href="#一-什么是全文检索" class="headerlink" title="一.什么是全文检索"></a>一.什么是全文检索</h1><h2 id="1-数据的分类"><a href="#1-数据的分类" class="headerlink" title="1. 数据的分类"></a>1. 数据的分类</h2><pre><code>1. 结构化数据
    格式固定-长度固定-数据类型固定
    如数据库中的数据

2. 非结构化数据
    word文档-pdf文档-邮件-html
    格式不固定-长度不固定-数据类型不固定</code></pre><h2 id="2-数据的查询"><a href="#2-数据的查询" class="headerlink" title="2.数据的查询"></a>2.数据的查询</h2><pre><code>1.结构化数据的查询
    SQL语句,查询结构化数据的方法.简单-速度快

2.非结构化数据的查询
    从文本文件中找出包含特定字符的文件
    1.目测
    2.使用程序把文档读取到内存中,然后匹配字符串,顺序扫描
    3.把非结构化数据变成结构化数据
        先根据空格进行字符串拆分,得到一个单词列表,基于单词列表创建一个索引
        然后查询索引,根据单词和文档的对应关系找到文档列表,这个过程叫全文检索

        索引:为了提高查询速度,创建某种数据结构的集合.</code></pre><a id="more"></a><h2 id="3-全文检索概念"><a href="#3-全文检索概念" class="headerlink" title="3.全文检索概念"></a>3.全文检索概念</h2><pre><code>先创建索引,然后查询索引的过程叫做全文检索
索引一次创建可以多次使用,每次查询速度都很快</code></pre><h1 id="二-全文检索的应用场景"><a href="#二-全文检索的应用场景" class="headerlink" title="二.全文检索的应用场景"></a>二.全文检索的应用场景</h1><h2 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1.搜索引擎"></a>1.搜索引擎</h2><pre><code>百度.360.搜狗.谷歌等</code></pre><h2 id="2-站内搜索"><a href="#2-站内搜索" class="headerlink" title="2.站内搜索"></a>2.站内搜索</h2><pre><code>论坛搜索.微博搜索.贴吧搜索</code></pre><h2 id="3-电商搜索"><a href="#3-电商搜索" class="headerlink" title="3.电商搜索"></a>3.电商搜索</h2><pre><code>淘宝.京东.拼多多</code></pre><h2 id="4-只要有搜索的地方-就可以使用全文检索技术"><a href="#4-只要有搜索的地方-就可以使用全文检索技术" class="headerlink" title="4.只要有搜索的地方,就可以使用全文检索技术"></a>4.只要有搜索的地方,就可以使用全文检索技术</h2><h1 id="三-什么是Lucene"><a href="#三-什么是Lucene" class="headerlink" title="三.什么是Lucene"></a>三.什么是Lucene</h1><p>Lucene是一个基于Java开发全文检索工具包</p>
<h1 id="四-Lucene实现全文检索的流程"><a href="#四-Lucene实现全文检索的流程" class="headerlink" title="四.Lucene实现全文检索的流程"></a>四.Lucene实现全文检索的流程</h1><p>流程图:</p>
<p><img src="https://i.loli.net/2019/10/12/KAjQqSBhL8YWZmt.png" alt></p>
<h2 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h2><pre><code>1.获得文档
    原始文档:要基于哪些数据来进行搜索,那这些数据就是原始文档
    搜索引擎:使用爬虫获得原始文档
    站内搜索:数据库中的数据
2.构建文档对象
    对应每个原始文档创建一个Document对象
    每个文档都有一个唯一的编号 文档id</code></pre><p><img src="https://i.loli.net/2019/10/12/ALmYdr5e6nZOasK.png" alt="2.png"></p>
<pre><code>3.分析文档
    就是分词的过程
    1.根据空格进行字符串拆分
    2.把单词统一换成小写
    3.去除标点符号
    4.去除停用词
        停用词:无意义的词
    每个关键词都封装成一个term对象
        term中包含两部分内容:
            关键词所在的域
            关键词本身
        不同的域中拆分出来的相同的关键词是不同的Term
4.创建索引
    基于关键词列表创建一个索引.保存到索引库中
    索引库中:
        索引
        Document对象
        关键词和文档的对应关系</code></pre><p><img src="https://i.loli.net/2019/10/12/T6lEvIBsD2RSjiH.png" alt="3.png"></p>
<pre><code>    注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。
传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。 
倒排索引结构是根据内容（词语）找文档，如下图：</code></pre><p><img src="https://i.loli.net/2019/10/12/mZUoV3x5OK92eWi.png" alt="4.png"></p>
<pre><code>倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。</code></pre><h2 id="2-查询索引"><a href="#2-查询索引" class="headerlink" title="2.查询索引"></a>2.查询索引</h2><pre><code>1.用户查询接口
    用户输入查询条件的地方
    如:搜索框
2.把关键词封装成一个查询对象
    查询对象:
        要查询的域
        要搜索的关键词
3.执行查询
    根据要查询的关键词到对应的域上进行搜索
    找到关键词,根据关键词找到对应的文档
4.渲染结果
    根据文档的id找到文档对象
    对关键词进行高亮显示
    分页处理
    最终展示结果</code></pre><h1 id="五-入门程序"><a href="#五-入门程序" class="headerlink" title="五.入门程序"></a>五.入门程序</h1><h2 id="1-创建索引-1"><a href="#1-创建索引-1" class="headerlink" title="1.创建索引"></a>1.创建索引</h2><pre><code>环境:
    下载Lucene.https://lucene.apache.org/
    最低jdk1.8

工程搭建:
    创建一个java工程
    添加jar:
        lucene-analyzers-common-7.4.0.jar
        lucene-core-7.4.0.jar
        commons-io.jar

步骤:
    1.创建一个Directory对象,指定索引库保存的位置
    2.基于Directory对象创建一个IndexWriter对象
    3.读取磁盘上的文件,对应每个文件创建一个文档对象
    4.向文档对象中添加域
    5.把文档对象写入索引库
    6.关闭IndexWriter对象</code></pre><p>主要代码:</p>
<pre><code>public class LuceneFirst {

    @Test
    public void createIndex()throws Exception {
        //1.创建一个Directory对象,指定索引库保存的位置
        //把索引库保存在内存中
        //Directory directory = new RAMDirectory();
        //把索引库保存在磁盘中
        Directory directory = FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath());
        //2.基于Directory对象创建一个IndexWriter对象
        IndexWriter indexWriter = new IndexWriter(directory,new IndexWriterConfig());
        //3.读取磁盘上的文件,对应每个文件创建一个文档对象
        File dir = new File(&quot;D:\\Homework\\Java\\searchsource&quot;);
        File[] files = dir.listFiles();
        for (File f : files) {
            //取文件名
            String fileName = f.getName();
            //文件路径
            String filePath = f.getPath();
            //文件的内容
            String fileContent = FileUtils.readFileToString(f, &quot;utf-8&quot;);
            //文件的大小
            long fileSize = FileUtils.sizeOf(f);
            //创建Field
            //参数1:域的名称  参数2:域的值  参数3:是否存储
            Field fieldName = new TextField(&quot;name&quot;,fileName, Field.Store.YES);
            Field fieldpath = new TextField(&quot;path&quot;,filePath, Field.Store.YES);
            Field fieldContent = new TextField(&quot;Content&quot;,fileContent, Field.Store.YES);
            Field fieldSize = new TextField(&quot;Size&quot;,fileSize+&quot;&quot;, Field.Store.YES);

            //创建文档对象
            Document document = new Document();
            //向文本对象添加域
            document.add(fieldName);
            document.add(fieldpath);
            document.add(fieldContent);
            document.add(fieldSize);
            //5.把文档对象写入索引库
            indexWriter.addDocument(document);
        }
        //6.关闭IndexWriter对象
        indexWriter.close();
    }
}</code></pre><h2 id="2-使用luke查看索引库中的内容"><a href="#2-使用luke查看索引库中的内容" class="headerlink" title="2.使用luke查看索引库中的内容"></a>2.使用luke查看索引库中的内容</h2><h2 id="3-查询索引库"><a href="#3-查询索引库" class="headerlink" title="3.查询索引库"></a>3.查询索引库</h2><pre><code>步骤:
    1.创建一个Directory对象,指定索引库的位置
    2.创建一个IndexReader对象
    3.创建一个IndexSearcher对象,构造方法中的参数就是IndexReader
    4.创建一个Query对象,TermQuery
    5.执行查询,得到一个TopDocs对象
    6.取查询结果的总记录数
    7.取文档列表
    8.打印文档中的内容
    9.关闭IndexReader对象</code></pre><p>代码:</p>
<pre><code>@Test
public void searchIndex() throws Exception {
    //1.创建一个Directory对象,指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath());
    //2.创建一个IndexReader对象
    IndexReader indexReader = DirectoryReader.open(directory);
    //3.创建一个IndexSearcher对象,构造方法中的参数就是IndexReader
    IndexSearcher indexSearcher = new IndexSearcher(indexReader);
    //4.创建一个Query对象,TermQuery
    Query query = new TermQuery(new Term(&quot;content&quot;,&quot;spring&quot;));
    //5.执行查询,得到一个TopDocs对象
    //参数1:查询对象  参数2:查询结果返回的最大纪录数
    TopDocs topDocs = indexSearcher.search(query, 10);
    //6.取查询结果的总记录数
    System.out.println(&quot;总记录数:&quot; + topDocs.totalHits);
    //7.取文档列表
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    //8.打印文档中的内容
    for (ScoreDoc scoreDoc : scoreDocs) {
        //取文档id
        int docId = scoreDoc.doc;
        //根据id取文档对象
        Document document = indexSearcher.doc(docId);
        System.out.println(document.get(&quot;name&quot;));
        System.out.println(document.get(&quot;path&quot;));
        System.out.println(document.get(&quot;size&quot;));
        //System.out.println(document.get(&quot;content&quot;));
        System.out.println(&quot;-----------------------------&quot;);
    }
    //9.关闭IndexReader对象
    indexReader.close();
}</code></pre><h1 id="六-分析器"><a href="#六-分析器" class="headerlink" title="六.分析器"></a>六.分析器</h1><p>默认使用的是标准分析器StandardAnalyzer</p>
<h2 id="1-查看分析器的分析效果"><a href="#1-查看分析器的分析效果" class="headerlink" title="1.查看分析器的分析效果"></a>1.查看分析器的分析效果</h2><pre><code>使用Analyzer对象的tokenStream方法返回一个TokenStream对象.此对象包含了最终的分词结果
实现步骤:
    1.创建一个Analyzer对象,StandardAnalyzer对象
    2.使用分析其对象的tokenStream方法返回一个TokenStream对象
    3.向TokenStream设置一个引用,相当于一个指针
    4.调用TokenStream对象的rest方法,如果不调用会抛异常
    5.使用while循环遍历TokenStream对象
    6.关闭TokenStream对象</code></pre><h2 id="2-IKAnalyze的使用方法啊-中文分析器"><a href="#2-IKAnalyze的使用方法啊-中文分析器" class="headerlink" title="2.IKAnalyze的使用方法啊(中文分析器)"></a>2.IKAnalyze的使用方法啊(中文分析器)</h2><pre><code>1.把IKAnalyze的jar包添加到工程
2.把配置文件和扩展词典添加到工程的classpath下
注:扩展词典不可以使用windows记事本编辑,保证扩展词典格式是utf-8
扩展词典:添加一些新词
停用词词典:无意义的词或者是敏感词汇</code></pre><h1 id="七-索引库的维护"><a href="#七-索引库的维护" class="headerlink" title="七.索引库的维护"></a>七.索引库的维护</h1><h2 id="1-Field域的属性"><a href="#1-Field域的属性" class="headerlink" title="1.Field域的属性"></a>1.Field域的属性</h2><pre><code>是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。

是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。
比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。

是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取
比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。

是否存储的标准：是否要将内容展示给用户</code></pre><p><img src="https://i.loli.net/2019/10/12/V1tcMAUz8kwsL3o.png" alt="5.png"></p>
<h2 id="2-添加文档代码实现"><a href="#2-添加文档代码实现" class="headerlink" title="2.添加文档代码实现"></a>2.添加文档代码实现</h2><pre><code>public void addDocument() throws Exception {
    //创建一个IndexWriter对象,使用IKAnalyzer作为分析器
    IndexWriter indexWriter = new IndexWriter(FSDirectory.open(new File(&quot;D:\\Homework\\Java\\temp\\index&quot;).toPath()),
            new IndexWriterConfig(new IKAnalyzer()));
    //创建一个Document对象
    Document document = new Document();
    //向document对象添加域
    document.add(new TextField(&quot;name&quot;,&quot;新添加的文件&quot;, Field.Store.YES));
    document.add(new TextField(&quot;content&quot;,&quot;新添加的文件内容&quot;, Field.Store.NO));
    document.add(new StoredField(&quot;path&quot;,&quot;D:\\Homework\\Java\\temp\\kobe&quot;));
    //把文档写入索引库
    indexWriter.addDocument(document);
    //关闭索引库
    indexWriter.close();
}</code></pre><h2 id="3-索引库删除"><a href="#3-索引库删除" class="headerlink" title="3.索引库删除"></a>3.索引库删除</h2><pre><code>public void deleteAllDocument() throws Exception {
    //删除全部文档
    indexWriter.deleteAll();
    //关闭索引库
    indexWriter.close();
}

public void deleteDocumentByQuery() throws Exception {
    //删除名字有apache的文件
    indexWriter.deleteDocuments(new Term(&quot;name&quot;,&quot;apache&quot;));
    indexWriter.close();
}</code></pre><h2 id="4-索引库的修改"><a href="#4-索引库的修改" class="headerlink" title="4.索引库的修改"></a>4.索引库的修改</h2><p>原理:先删除,后添加</p>
<pre><code>public void updateDocument() throws Exception {
    //创建一个新的文档对象
    Document document = new Document();
    //向文档对象添加域
    document.add(new TextField(&quot;name1&quot;,&quot;更新后的文档1&quot;, Field.Store.YES));
    document.add(new TextField(&quot;name2&quot;,&quot;更新后的文档2&quot;, Field.Store.YES));
    document.add(new TextField(&quot;name3&quot;,&quot;更新后的文档3&quot;, Field.Store.YES));
    //更新
    //参数1:要删除的文档  参数2:添加的文档
    indexWriter.updateDocument(new Term(&quot;name&quot;,&quot;spring&quot;),document);
    //关闭索引库
    indexWriter.close();
}</code></pre><h1 id="八-索引库的查询"><a href="#八-索引库的查询" class="headerlink" title="八.索引库的查询"></a>八.索引库的查询</h1><h2 id="1-使用Query的子类"><a href="#1-使用Query的子类" class="headerlink" title="1.使用Query的子类"></a>1.使用Query的子类</h2><pre><code>1.TermQuery
    根据关键词进行查询
    需要指定要查询的域及要查询的关键词

2.RangeQuery</code></pre><p>代码:</p>
<pre><code>public void testRangeQuery() throws Exception {
    //创建一个Query对象
    Query query = LongPoint.newRangeQuery(&quot;size&quot;, 0, 100);
    printResult(query);
}

private void printResult(Query query) throws Exception {
    //执行查询
    TopDocs topDocs = indexSearcher.search(query, 10);
    //遍历
    System.out.println(&quot;总记录数:&quot; + topDocs.totalHits);
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    for (ScoreDoc scoreDoc : scoreDocs) {
        int docId = scoreDoc.doc;
        //根据id取文档对象
        Document document = indexSearcher.doc(docId);
        System.out.println(document.get(&quot;name&quot;));
        System.out.println(document.get(&quot;path&quot;));
        System.out.println(document.get(&quot;size&quot;));
        //System.out.println(document.get(&quot;content&quot;));
        System.out.println(&quot;-----------------------------&quot;);
    }
    //9.关闭IndexReader对象
    indexReader.close();
}</code></pre><hr>
<pre><code>3.使用queryparser查询
    可以对要查询的内容先分词,然后基于分词的结果进行查询
    添加jar包
    lucene-queryparser-7.4.0.jar</code></pre><p>代码:</p>
<pre><code>public void testQueryParser() throws Exception {
    //创建一个QueryParser对象
    //参数1:默认搜索域  参数2:分析器对象
    QueryParser queryParser = new QueryParser(&quot;name&quot;,new IKAnalyzer());
    //使用QueryParser对象创建一个Query对象
    Query query = queryParser.parse(&quot;lucene是一个java开发的全文检索工具包&quot;);
    //执行查询
    printResult(query);
}</code></pre>]]></content>
      <categories>
        <category>搜索技术</category>
      </categories>
      <tags>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2019/10/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="换了个博客框架-之前自己做的实在是太丑了-忍不了…会陆续将之前的笔记搬运过来"><a href="#换了个博客框架-之前自己做的实在是太丑了-忍不了…会陆续将之前的笔记搬运过来" class="headerlink" title="换了个博客框架,之前自己做的实在是太丑了,忍不了…会陆续将之前的笔记搬运过来"></a>换了个博客框架,之前自己做的实在是太丑了,忍不了…会陆续将之前的笔记搬运过来</h2>]]></content>
  </entry>
</search>
